# -*- coding: utf-8 -*-
import os
import sys
import json
import webbrowser
import requests
import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
from threading import Thread
import re
import threading
import platform
import subprocess
import datetime
import time
from urllib.parse import quote_plus
import logging

# å¯¼å…¥è‡ªå®šä¹‰æ¨¡å?
from api_manager import APIManager
from knowledge_manager import KnowledgeManager
from paper_downloader import PaperDownloader

# åˆ›å»ºæµ‹è¯•ä¸‹è½½æ‰¹å¤„ç†æ–‡ä»?
def create_test_batch_file():
    """åˆ›å»ºæµ‹è¯•ä¸‹è½½çš„æ‰¹å¤„ç†æ–‡ä»¶"""
    try:
        # æ‰¹å¤„ç†æ–‡ä»¶è·¯å¾?
        batch_file = "test_download.bat"
        
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if os.path.exists(batch_file):
            # æŸ¥çœ‹æ–‡ä»¶ä¿®æ”¹æ—¶é—´ï¼Œå¦‚æœä¸æ˜¯ä»Šå¤©åˆ›å»ºçš„ï¼Œåˆ™é‡æ–°åˆ›å»º
            mod_time = os.path.getmtime(batch_file)
            mod_date = datetime.datetime.fromtimestamp(mod_time).date()
            today = datetime.datetime.now().date()
            
            if mod_date == today:
                return  # ä»Šå¤©å·²ç»åˆ›å»ºè¿‡ï¼Œä¸éœ€è¦é‡æ–°åˆ›å»?
        
        # åˆ›å»ºæ‰¹å¤„ç†æ–‡ä»¶å†…å®?
        content = """@echo off
echo æ­£åœ¨å¯åŠ¨ä¸‹è½½æµ‹è¯•...
echo è¿™å°†å¯åŠ¨AIåŠ©æ‰‹å¹¶è‡ªåŠ¨æ‰§è¡Œä¸‹è½½æµ‹è¯?

REM å¯åŠ¨Pythonç¨‹åºå¹¶ä¼ é€’æµ‹è¯•æ ‡å¿?
python ai_assistant.py --test-download

echo æµ‹è¯•å®Œæˆ
pause
"""
        
        # å†™å…¥æ–‡ä»¶
        with open(batch_file, "w") as f:
            f.write(content)
        
        print(f"å·²åˆ›å»ºæµ‹è¯•ä¸‹è½½æ‰¹å¤„ç†æ–‡ä»¶: {batch_file}")
    except Exception as e:
        print(f"åˆ›å»ºæ‰¹å¤„ç†æ–‡ä»¶å¤±è´? {str(e)}")

def check_encoding_issues():
    """æ£€æŸ¥å¹¶ä¿®å¤å¯èƒ½çš„ç¼–ç é—®é¢?""
    try:
        import chardet
        
        # æ£€æµ‹å½“å‰æ–‡ä»¶çš„ç¼–ç 
        with open(__file__, 'rb') as f:
            result = chardet.detect(f.read())
        
        file_encoding = result['encoding']
        confidence = result['confidence']
        
        # æ‰“å°ç¼–ç ä¿¡æ¯
        print(f"æ–‡ä»¶ç¼–ç æ£€æµ? {file_encoding}, å¯ä¿¡åº? {confidence:.2f}")
        
        # å¦‚æœä¸æ˜¯UTF-8ç¼–ç ï¼Œå°è¯•è½¬æ?
        if file_encoding and file_encoding.lower() != 'utf-8' and confidence > 0.7:
            try:
                # è¯»å–å½“å‰æ–‡ä»¶
                with open(__file__, 'rb') as f:
                    content = f.read()
                
                # è§£ç å¹¶é‡æ–°ç¼–ç ä¸ºUTF-8
                decoded = content.decode(file_encoding, errors='replace')
                utf8_content = decoded.encode('utf-8')
                
                # åˆ›å»ºå¤‡ä»½
                backup_file = __file__ + '.backup'
                with open(backup_file, 'wb') as f:
                    f.write(content)
                
                # é‡å†™æ–‡ä»¶ä¸ºUTF-8
                with open(__file__, 'wb') as f:
                    f.write(utf8_content)
                
                print(f"å·²å°†æ–‡ä»¶ä»?{file_encoding} è½¬æ¢ä¸?UTF-8ï¼ŒåŸæ–‡ä»¶å·²å¤‡ä»½ä¸º {backup_file}")
            except Exception as e:
                print(f"è½¬æ¢æ–‡ä»¶ç¼–ç æ—¶å‡ºé”? {str(e)}")
    except ImportError:
        print("ç¼ºå°‘chardetåº“ï¼Œæ— æ³•æ£€æµ‹æ–‡ä»¶ç¼–ç ã€‚è¯·å®‰è£…: pip install chardet")
    except Exception as e:
        print(f"æ£€æŸ¥ç¼–ç æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")

class AIAssistant:
    def __init__(self, root):
        """åˆå§‹åŒ–AIåŠ©æ‰‹"""
        self.root = root
        root.title("AIè®ºæ–‡åŠ©æ‰‹")
        
        # è®¾ç½®æœ€å°çª—å£å¤§å°?
        root.minsize(900, 700)
        
        # åˆå§‹åŒ–å…³é”®ç®¡ç†å™¨
        self.api_manager = APIManager()
        self.paper_downloader = PaperDownloader("downloaded_papers")
        self.knowledge_manager = KnowledgeManager()
        
        # åˆ›å»ºTabæ§ä»¶
        self.tab_control = ttk.Notebook(root)
        
        # åˆ›å»ºå„ä¸ªé€‰é¡¹å?
        self.chat_tab = ttk.Frame(self.tab_control)
        self.paper_tab = ttk.Frame(self.tab_control)
        self.knowledge_tab = ttk.Frame(self.tab_control)
        self.settings_tab = ttk.Frame(self.tab_control)
        
        # æ·»åŠ é€‰é¡¹å¡åˆ°Tabæ§ä»¶
        self.tab_control.add(self.chat_tab, text="AIèŠå¤©")
        self.tab_control.add(self.paper_tab, text="æ–‡çŒ®ä¸‹è½½")
        self.tab_control.add(self.knowledge_tab, text="çŸ¥è¯†åº?)
        self.tab_control.add(self.settings_tab, text="è®¾ç½®")
        
        self.tab_control.pack(expand=1, fill="both")
        
        # å­˜å‚¨ä¸‹è½½çŠ¶æ€å’Œç»“æœ
        self.selected_paper = None
        self.last_download_path = None
        self.paper_results = []
        
        # åˆå§‹åŒ–æç¤?
        self.prompt_template = ""
        
        # å­˜å‚¨èŠå¤©å†å²
        self.chat_history = []
        
        # åˆå§‹åŒ–ç»„ä»?
        self.setup_chat_tab()
        self.setup_paper_tab()
        self.setup_knowledge_tab()
        self.setup_settings_tab()
        
        # åŠ è½½è®¾ç½®
        self.load_settings()
    
    def setup_chat_tab(self):
        # å¯¹è¯å†å²
        chat_frame = ttk.Frame(self.chat_tab)
        chat_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        self.chat_history = scrolledtext.ScrolledText(chat_frame, wrap=tk.WORD, font=("Arial", 10))
        self.chat_history.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.chat_history.config(state=tk.DISABLED)
        
        # è¾“å…¥åŒºåŸŸ
        input_frame = ttk.Frame(self.chat_tab)
        input_frame.pack(fill=tk.X, pady=5)
        
        self.user_input = scrolledtext.ScrolledText(input_frame, wrap=tk.WORD, height=4, font=("Arial", 10))
        self.user_input.pack(fill=tk.X, padx=5, pady=5, side=tk.LEFT, expand=True)
        self.user_input.bind("<Control-Return>", self.send_message)
        
        button_frame = ttk.Frame(input_frame)
        button_frame.pack(side=tk.RIGHT, padx=5)
        
        self.send_button = ttk.Button(button_frame, text="å‘é€?, command=self.send_message)
        self.send_button.pack(pady=2)
        
        self.clear_button = ttk.Button(button_frame, text="æ¸…é™¤", command=self.clear_chat)
        self.clear_button.pack(pady=2)
        
        # APIé€‰æ‹©
        api_frame = ttk.Frame(self.chat_tab)
        api_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(api_frame, text="é€‰æ‹©API:").pack(side=tk.LEFT, padx=5)
        
        self.api_var = tk.StringVar()
        # è·å–æ‰€æœ‰å¯ç”¨çš„API
        self.api_choices = self.api_manager.get_available_apis()
        self.api_dropdown = ttk.Combobox(api_frame, textvariable=self.api_var, values=self.api_choices, state="readonly")
        self.api_dropdown.pack(side=tk.LEFT, padx=5)
        if self.api_choices:
            self.api_dropdown.current(0)
        
        # æ·»åŠ ä½¿ç”¨çŸ¥è¯†åº“é€‰é¡¹
        self.use_knowledge_var = tk.BooleanVar()
        self.use_knowledge_var.set(False)
        ttk.Checkbutton(api_frame, text="ä½¿ç”¨çŸ¥è¯†åº“å¢å¼?, variable=self.use_knowledge_var).pack(side=tk.LEFT, padx=15)
    
    def setup_knowledge_tab(self):
        """è®¾ç½®çŸ¥è¯†åº“é€‰é¡¹å?""
        # åˆ†ä¸ºå·¦å³ä¸¤éƒ¨åˆ†å¸ƒå±€
        main_frame = ttk.Frame(self.knowledge_tab)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # å·¦ä¾§ï¼šåˆ†åŒºé€‰æ‹©å’Œæ–‡ä»¶åˆ—è¡?
        left_frame = ttk.Frame(main_frame)
        left_frame.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        
        # åˆ†åŒºé€‰æ‹©æ¡†æ¶
        category_frame = ttk.LabelFrame(left_frame, text="çŸ¥è¯†åº“åˆ†åŒ?)
        category_frame.pack(fill="x", padx=5, pady=5)
        
        # åˆ†åŒºé€‰æ‹©å˜é‡
        self.selected_category = tk.StringVar(value="å…¨éƒ¨")
        
        # æ·»åŠ åˆ†åŒºé€‰æ‹©å•é€‰æŒ‰é’?
        categories = ["å…¨éƒ¨"] + self.knowledge_manager.categories
        for category in categories:
            rb = ttk.Radiobutton(
                category_frame, 
                text=category, 
                value=category, 
                variable=self.selected_category,
                command=self.refresh_knowledge_list
            )
            rb.pack(anchor="w", padx=10, pady=2)
        
        # æ–‡ä»¶åˆ—è¡¨æ¡†æ¶
        files_frame = ttk.LabelFrame(left_frame, text="æ–‡ä»¶åˆ—è¡¨")
        files_frame.pack(fill="both", expand=True, padx=5, pady=5)
        
        # åˆ›å»ºåˆ—è¡¨å’Œæ»šåŠ¨æ¡
        self.knowledge_list = tk.Listbox(files_frame, height=15)
        scrollbar = ttk.Scrollbar(files_frame, orient="vertical", command=self.knowledge_list.yview)
        self.knowledge_list.configure(yscrollcommand=scrollbar.set)
        
        self.knowledge_list.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        scrollbar.pack(side="right", fill="y", padx=5, pady=5)
        
        # ç»‘å®šé€‰æ‹©äº‹ä»¶
        self.knowledge_list.bind("<<ListboxSelect>>", self.on_knowledge_file_select)
        self.knowledge_list.bind("<Double-1>", self.open_knowledge_file)
        
        # æ“ä½œæŒ‰é’®
        buttons_frame = ttk.Frame(left_frame)
        buttons_frame.pack(fill="x", padx=5, pady=5)
        
        # æ·»åŠ æ–‡ä»¶æŒ‰é’®
        add_button = ttk.Button(buttons_frame, text="æ·»åŠ æ–‡ä»¶", command=self.upload_to_knowledge_base)
        add_button.pack(side="left", padx=5, pady=5)
        
        # åˆ é™¤æ–‡ä»¶æŒ‰é’®
        self.delete_button = ttk.Button(buttons_frame, text="åˆ é™¤æ–‡ä»¶", command=self.delete_from_knowledge_base, state="disabled")
        self.delete_button.pack(side="left", padx=5, pady=5)
        
        # åˆ·æ–°æŒ‰é’®
        refresh_button = ttk.Button(buttons_frame, text="åˆ·æ–°åˆ—è¡¨", command=self.refresh_knowledge_list)
        refresh_button.pack(side="right", padx=5, pady=5)
        
        # å³ä¾§ï¼šæ–‡ä»¶è¯¦æƒ…å’Œé¢„è§ˆ
        right_frame = ttk.Frame(main_frame)
        right_frame.pack(side="right", fill="both", expand=True, padx=5, pady=5)
        
        # æ–‡ä»¶è¯¦æƒ…æ¡†æ¶
        details_frame = ttk.LabelFrame(right_frame, text="æ–‡ä»¶è¯¦æƒ…")
        details_frame.pack(fill="x", padx=5, pady=5)
        
        # è¯¦æƒ…æ ‡ç­¾
        self.file_title_label = ttk.Label(details_frame, text="æ ‡é¢˜: ")
        self.file_title_label.pack(anchor="w", padx=10, pady=2)
        
        self.file_authors_label = ttk.Label(details_frame, text="ä½œè€? ")
        self.file_authors_label.pack(anchor="w", padx=10, pady=2)
        
        self.file_year_label = ttk.Label(details_frame, text="å¹´ä»½: ")
        self.file_year_label.pack(anchor="w", padx=10, pady=2)
        
        self.file_category_label = ttk.Label(details_frame, text="åˆ†åŒº: ")
        self.file_category_label.pack(anchor="w", padx=10, pady=2)
        
        self.file_path_label = ttk.Label(details_frame, text="è·¯å¾„: ")
        self.file_path_label.pack(anchor="w", padx=10, pady=2)
        
        # æ–‡ä»¶é¢„è§ˆæ¡†æ¶
        preview_frame = ttk.LabelFrame(right_frame, text="æ–‡ä»¶é¢„è§ˆ")
        preview_frame.pack(fill="both", expand=True, padx=5, pady=5)
        
        # åˆ›å»ºæ–‡æœ¬æ¡†å’Œæ»šåŠ¨æ?
        self.preview_text = tk.Text(preview_frame, wrap="word")
        preview_scrollbar = ttk.Scrollbar(preview_frame, orient="vertical", command=self.preview_text.yview)
        self.preview_text.configure(yscrollcommand=preview_scrollbar.set)
        
        self.preview_text.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        preview_scrollbar.pack(side="right", fill="y", padx=5, pady=5)
        
        # åˆå§‹åŒ–æ—¶åŠ è½½æ–‡ä»¶åˆ—è¡¨
        self.refresh_knowledge_list()
    
    def setup_settings_tab(self):
        """è®¾ç½®APIé…ç½®é€‰é¡¹å?""
        # åˆå§‹åŒ–APIç®¡ç†å™¨ï¼Œå¦‚æœå°šæœªåˆå§‹åŒ?
        if not hasattr(self, 'api_manager'):
            self.api_manager = APIManager()
            
        # åˆ›å»ºAPIç±»å‹é€‰æ‹©ä¸‹æ‹‰æ¡?
        ttk.Label(self.settings_tab, text="é€‰æ‹©APIç±»å‹:").pack(anchor="w", padx=10, pady=5)
        
        settings_frame = ttk.Frame(self.settings_tab)
        settings_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # åˆ›å»ºä¸€ä¸ªå¸¦æ»šåŠ¨æ¡çš„Canvasï¼Œç”¨äºå®¹çº³æ‰€æœ‰è®¾ç½?
        canvas = tk.Canvas(settings_frame)
        scrollbar = ttk.Scrollbar(settings_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # OpenAIè®¾ç½®
        openai_frame = ttk.LabelFrame(scrollable_frame, text="OpenAIè®¾ç½®")
        openai_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(openai_frame, text="API Key:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        self.openai_key = ttk.Entry(openai_frame, width=50, show="*")
        self.openai_key.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)
        
        ttk.Label(openai_frame, text="æ¨¡å‹:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)
        self.openai_model = ttk.Entry(openai_frame, width=30)
        self.openai_model.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)
        self.openai_model.insert(0, "gpt-4")
        
        # Azure OpenAIè®¾ç½®
        azure_frame = ttk.LabelFrame(scrollable_frame, text="Azure OpenAIè®¾ç½®")
        azure_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(azure_frame, text="API Key:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        self.azure_key = ttk.Entry(azure_frame, width=50, show="*")
        self.azure_key.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)
        
        ttk.Label(azure_frame, text="Endpoint:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)
        self.azure_endpoint = ttk.Entry(azure_frame, width=50)
        self.azure_endpoint.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)
        
        ttk.Label(azure_frame, text="éƒ¨ç½²åç§°:").grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)
        self.azure_deployment = ttk.Entry(azure_frame, width=30)
        self.azure_deployment.grid(row=2, column=1, padx=5, pady=5, sticky=tk.W)
        
        # DeepSeekè®¾ç½®
        deepseek_frame = ttk.LabelFrame(scrollable_frame, text="DeepSeekè®¾ç½®")
        deepseek_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(deepseek_frame, text="API Key:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        self.deepseek_key = ttk.Entry(deepseek_frame, width=50, show="*")
        self.deepseek_key.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)
        
        ttk.Label(deepseek_frame, text="æ¨¡å‹:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)
        self.deepseek_model = ttk.Entry(deepseek_frame, width=30)
        self.deepseek_model.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)
        self.deepseek_model.insert(0, "deepseek-chat")
        
        ttk.Label(deepseek_frame, text="APIåœ°å€:").grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)
        self.deepseek_url = ttk.Entry(deepseek_frame, width=50)
        self.deepseek_url.grid(row=2, column=1, padx=5, pady=5, sticky=tk.W)
        self.deepseek_url.insert(0, "https://api.deepseek.com/v1")
        
        # æœ¬åœ°æ¨¡å‹è®¾ç½®
        local_frame = ttk.LabelFrame(scrollable_frame, text="æœ¬åœ°æ¨¡å‹è®¾ç½®")
        local_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(local_frame, text="APIåœ°å€:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        self.local_api = ttk.Entry(local_frame, width=50)
        self.local_api.grid(row=0, column=1, padx=5, pady=5, sticky=tk.W)
        self.local_api.insert(0, "http://localhost:8000/v1")
        
        # å…¶ä»–APIè®¾ç½®
        other_frame = ttk.LabelFrame(scrollable_frame, text="å…¶ä»–APIè®¾ç½®")
        other_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(other_frame, text="APIæ’ä»¶ç›®å½•:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        plugin_path = os.path.abspath("api_plugins")
        ttk.Label(other_frame, text=plugin_path).grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)
        
        ttk.Button(other_frame, text="æ‰“å¼€æ’ä»¶ç›®å½•", 
                   command=lambda: self.open_directory(plugin_path)).grid(row=1, column=0, padx=5, pady=5)
        ttk.Button(other_frame, text="åˆ·æ–°APIåˆ—è¡¨", 
                   command=self.refresh_api_list).grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)
        
        # ä¿å­˜è®¾ç½®æŒ‰é’®
        save_frame = ttk.Frame(scrollable_frame)
        save_frame.pack(pady=10)
        
        ttk.Button(save_frame, text="ä¿å­˜è®¾ç½®", command=self.save_settings).pack(pady=5)
    
    def setup_paper_tab(self):
        """è®¾ç½®æ–‡çŒ®ä¸‹è½½é€‰é¡¹å?""
        # åˆå§‹åŒ–è®ºæ–‡ä¸‹è½½å™¨ï¼Œå¦‚æœå°šæœªåˆå§‹åŒ–
        if not hasattr(self, 'paper_downloader'):
            self.paper_downloader = PaperDownloader("downloaded_papers")
            
        # åˆå§‹åŒ–çŸ¥è¯†åº“ç®¡ç†å™¨ï¼Œå¦‚æœå°šæœªåˆå§‹åŒ?
        if not hasattr(self, 'knowledge_manager'):
            self.knowledge_manager = KnowledgeManager()
            
        # æœç´¢æ¡†å’ŒæŒ‰é’®
        search_frame = ttk.Frame(self.paper_tab)
        search_frame.pack(fill="x", padx=10, pady=10)
        
        ttk.Label(search_frame, text="è®ºæ–‡æœç´¢:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        self.search_entry = ttk.Entry(search_frame, width=50)
        self.search_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")
        self.search_entry.bind("<Return>", lambda e: self.search_papers())
        
        self.search_button = ttk.Button(search_frame, text="æœç´¢", command=self.search_papers)
        self.search_button.grid(row=0, column=2, padx=5, pady=5)
        
        # åˆ›å»ºä¸‹è½½æºé€‰æ‹©
        ttk.Label(search_frame, text="æ¥æº:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        
        # æ·»åŠ ç™¾åº¦å­¦æœ¯å’Œä¸­å›½çŸ¥ç½‘åˆ°æ¥æºåˆ—è¡¨
        sources = self.paper_downloader.sources + ["ç™¾åº¦å­¦æœ¯", "ä¸­å›½çŸ¥ç½‘"]
        self.source_var = tk.StringVar(value="Google Scholar")  # é»˜è®¤é€‰æ‹©Google Scholar
        source_combo = ttk.Combobox(search_frame, textvariable=self.source_var,
                                   values=sources,
                                   state="readonly", width=20)
        source_combo.grid(row=1, column=1, padx=5, pady=5, sticky="w")
        
        # æµ‹è¯•ä¸‹è½½æŒ‰é’®
        self.test_download_button = ttk.Button(
            search_frame, text="æµ‹è¯•ä¸‹è½½åŠŸèƒ½", 
            command=self.test_download_function)
        self.test_download_button.grid(row=1, column=2, padx=5, pady=5)
        
        # æ·»åŠ æœç´¢çŠ¶æ€æ ‡ç­?
        self.search_status_var = tk.StringVar(value="å°±ç»ª")
        search_status_label = ttk.Label(search_frame, textvariable=self.search_status_var)
        search_status_label.grid(row=0, column=4, padx=5, pady=5, sticky="w")
        
        # å¿«é€ŸDOI/ArXiv IDä¸‹è½½
        doi_frame = ttk.LabelFrame(self.paper_tab, text="å¿«é€ŸDOI/ArXiv IDä¸‹è½½")
        doi_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(doi_frame, text="è¾“å…¥DOIæˆ–ArXiv ID:").pack(side="left", padx=5, pady=5)
        self.doi_entry = ttk.Entry(doi_frame, width=50)
        self.doi_entry.pack(side="left", padx=5, pady=5, fill="x", expand=True)
        self.doi_entry.bind("<Return>", lambda e: self.quick_access())
        
        self.doi_button = ttk.Button(doi_frame, text="ä¸‹è½½", command=self.quick_access)
        self.doi_button.pack(side="left", padx=5, pady=5)
        
        # æ­£ç¡®è®¾ç½®quick_access_buttonå˜é‡
        self.quick_access_button = ttk.Button(doi_frame, text="æ£€æŸ?, command=self.quick_access)
        self.quick_access_button.pack(side="left", padx=5, pady=5)
        
        # åˆ›å»ºä¸‹è½½è¿›åº¦æ?
        progress_frame = ttk.Frame(self.paper_tab)
        progress_frame.pack(fill="x", padx=10, pady=5)
        
        self.download_progress = ttk.Progressbar(progress_frame, orient="horizontal", length=300, mode="determinate")
        self.download_progress.pack(side="left", padx=5, pady=5, fill="x", expand=True)
        
        self.paper_status_label = ttk.Label(progress_frame, text="å‡†å¤‡å°±ç»ª")
        self.paper_status_label.pack(side="left", padx=5, pady=5)
        
        # åˆ›å»ºæœç´¢è¿›åº¦æŒ‡ç¤ºå™?
        self.search_progress = ttk.Progressbar(progress_frame, orient="horizontal", length=100, mode="indeterminate")
        self.search_progress.pack(side="right", padx=5, pady=5)
        
        # åˆ›å»ºä¸»æ¡†æ¶ï¼šå·¦ä¾§ç»“æœåˆ—è¡¨ï¼Œå³ä¾§è¯¦ç»†ä¿¡æ?
        paper_main_frame = ttk.Frame(self.paper_tab)
        paper_main_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        # å·¦ä¾§ï¼šæœç´¢ç»“æ?
        left_frame = ttk.Frame(paper_main_frame)
        left_frame.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        
        # æœç´¢ç»“æœæ¡†æ¶
        results_frame = ttk.LabelFrame(left_frame, text="æœç´¢ç»“æœ")
        results_frame.pack(fill="both", expand=True, padx=0, pady=0)
        
        # ä½¿ç”¨Treeviewæ˜¾ç¤ºæœç´¢ç»“æœ
        columns = ("title", "authors", "year", "source")
        self.results_tree = ttk.Treeview(results_frame, columns=columns, show="headings", selectmode="browse", height=10)
        
        # å®šä¹‰åˆ?
        self.results_tree.heading("title", text="æ ‡é¢˜")
        self.results_tree.heading("authors", text="ä½œè€?)
        self.results_tree.heading("year", text="å¹´ä»½")
        self.results_tree.heading("source", text="æ¥æº")
        
        # è®¾ç½®åˆ—å®½
        self.results_tree.column("title", width=300)
        self.results_tree.column("authors", width=150)
        self.results_tree.column("year", width=50)
        self.results_tree.column("source", width=80)
        
        # æ·»åŠ æ»šåŠ¨æ?
        results_scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.results_tree.yview)
        self.results_tree.configure(yscrollcommand=results_scrollbar.set)
        
        # å¸ƒå±€
        self.results_tree.pack(side="left", fill="both", expand=True)
        results_scrollbar.pack(side="right", fill="y")
        
        # ç»‘å®šé€‰æ‹©äº‹ä»¶
        self.results_tree.bind("<<TreeviewSelect>>", self.on_result_select)
        
        # å³ä¾§ï¼šè®ºæ–‡è¯¦æƒ?
        right_frame = ttk.Frame(paper_main_frame)
        right_frame.pack(side="right", fill="both", expand=True, padx=5, pady=5)
        
        # è¯¦æƒ…æ¡†æ¶
        details_frame = ttk.LabelFrame(right_frame, text="è®ºæ–‡è¯¦æƒ…")
        details_frame.pack(fill="both", expand=True, padx=0, pady=0)
        
        # åˆ›å»ºæ–‡æœ¬æ¡†ç”¨äºæ˜¾ç¤ºè¯¦æƒ?
        self.paper_details_text = tk.Text(details_frame, wrap="word", width=40, height=15)
        details_scrollbar = ttk.Scrollbar(details_frame, orient="vertical", command=self.paper_details_text.yview)
        self.paper_details_text.configure(yscrollcommand=details_scrollbar.set)
        
        self.paper_details_text.pack(side="left", fill="both", expand=True)
        details_scrollbar.pack(side="right", fill="y")
        
        # é…ç½®æ ·å¼
        self.paper_details_text.tag_configure("title", font=("Arial", 12, "bold"))
        self.paper_details_text.tag_configure("heading", font=("Arial", 10, "bold"))
        self.paper_details_text.tag_configure("link", foreground="blue", underline=1)
        self.paper_details_text.bind("<Button-1>", self.open_url)
        
        # æ·»åŠ æŒ‰é’®åŒºåŸŸ
        buttons_frame = ttk.Frame(self.paper_tab)
        buttons_frame.pack(fill="x", padx=10, pady=5)
        
        self.download_button = ttk.Button(buttons_frame, text="ä¸‹è½½é€‰ä¸­è®ºæ–‡", command=self.download_selected_paper, state="disabled")
        self.download_button.pack(side="left", padx=5, pady=5)
        
        self.open_browser_button = ttk.Button(buttons_frame, text="åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€", command=self.open_url_in_browser, state="disabled")
        self.open_browser_button.pack(side="left", padx=5, pady=5)
        
        # æ·»åŠ çŸ¥è¯†åº“å¯¼å…¥æŒ‰é’?
        self.add_to_kb_button = ttk.Button(buttons_frame, text="å¯¼å…¥åˆ°çŸ¥è¯†åº“", command=self.add_paper_to_kb, state="disabled")
        self.add_to_kb_button.pack(side="left", padx=5, pady=5)
        
        # æ·»åŠ å–æ¶ˆæŒ‰é’®ï¼ˆé»˜è®¤ç¦ç”¨ï¼‰
        self.cancel_search_button = ttk.Button(buttons_frame, text="å–æ¶ˆæœç´¢", command=self.cancel_search, state="disabled")
        self.cancel_search_button.pack(side="left", padx=5, pady=5)
        
        # æ·»åŠ åˆ·æ–°æŒ‰é’®
        refresh_button = ttk.Button(buttons_frame, text="åˆ·æ–°ä¸‹è½½åˆ—è¡¨", command=self.refresh_downloaded_files)
        refresh_button.pack(side="right", padx=5, pady=5)
        
        # åˆ›å»ºå·²ä¸‹è½½æ–‡ä»¶åˆ—è¡?
        downloads_frame = ttk.LabelFrame(self.paper_tab, text="å·²ä¸‹è½½è®ºæ–?)
        downloads_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        # åˆ›å»ºä¸‹è½½æ–‡ä»¶åˆ—è¡¨
        self.downloaded_files_list = tk.Listbox(downloads_frame, height=8)
        self.downloaded_files_list.pack(side="left", fill="both", expand=True)
        
        # æ·»åŠ æ»šåŠ¨æ?
        downloads_scrollbar = ttk.Scrollbar(downloads_frame, orient="vertical", command=self.downloaded_files_list.yview)
        self.downloaded_files_list.configure(yscrollcommand=downloads_scrollbar.set)
        downloads_scrollbar.pack(side="right", fill="y")
        
        # ç»‘å®šåŒå‡»äº‹ä»¶
        self.downloaded_files_list.bind("<Double-1>", self.on_file_double_click)
        self.downloaded_files_list.bind("<<ListboxSelect>>", self.on_file_select)
        
        # æ–‡ä»¶æ“ä½œæŒ‰é’®
        file_buttons_frame = ttk.Frame(self.paper_tab)
        file_buttons_frame.pack(fill="x", padx=10, pady=5)
        
        open_file_button = ttk.Button(file_buttons_frame, text="æ‰“å¼€æ–‡ä»¶", command=self.open_selected_file)
        open_file_button.pack(side="left", padx=5, pady=5)
        
        self.add_file_to_kb_button = ttk.Button(file_buttons_frame, text="æ·»åŠ åˆ°çŸ¥è¯†åº“", command=self.add_downloaded_to_kb)
        self.add_file_to_kb_button.pack(side="left", padx=5, pady=5)
        
        open_folder_button = ttk.Button(file_buttons_frame, text="æ‰“å¼€ä¸‹è½½æ–‡ä»¶å¤?, command=self.open_papers_folder)
        open_folder_button.pack(side="right", padx=5, pady=5)
        
        # åˆå§‹åŒ–ä¸‹è½½ç›®å½?
        self.papers_dir = "downloaded_papers"
        if not os.path.exists(self.papers_dir):
            os.makedirs(self.papers_dir)
            
        # åˆ·æ–°å·²ä¸‹è½½æ–‡ä»¶åˆ—è¡?
        self.refresh_downloaded_files()
        
        # åˆå§‹åŒ–æœç´¢æ§åˆ¶å˜é‡?
        self.search_thread = None
        self.cancel_search_flag = False
        
        # æ›´æ–°çŠ¶æ€?
        self.paper_status_label.config(text="å‡†å¤‡å°±ç»ª")
    
    def cancel_search(self):
        """å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„æœç´?""
        if self.search_thread and self.search_thread.is_alive():
            self.cancel_search_flag = True
            self.search_status_var.set("æ­£åœ¨å–æ¶ˆ...")
            self.cancel_search_button.config(state="disabled")
            
    def search_papers(self):
        """æœç´¢è®ºæ–‡"""
        query = self.search_entry.get().strip()
        if not query:
            self.paper_status_label.config(text="è¯·è¾“å…¥æœç´¢å…³é”®è¯")
            return
        
        source = self.source_var.get()
        
        # é‡ç½®å–æ¶ˆæ ‡å¿—
        self.cancel_search_flag = False
        
        # æ›´æ–°UIçŠ¶æ€?
        self.search_button.config(state="disabled")
        self.cancel_search_button.config(state="normal")
        self.search_status_var.set("æœç´¢ä¸?..")
        self.search_progress.start(10)
        
        # æ¸…ç©ºä¹‹å‰çš„ç»“æ?
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # æ¸…ç©ºå½“å‰è®ºæ–‡è¯¦æƒ…
        self.clear_paper_details()
        
        # ä½¿ç”¨çº¿ç¨‹å¼‚æ­¥æ‰§è¡Œæœç´¢
        self.search_thread = threading.Thread(target=self._execute_search, args=(query, source))
        self.search_thread.daemon = True
        self.search_thread.start()
    
    def _execute_search(self, query, source):
        """æ‰§è¡Œæœç´¢æ“ä½œ"""
        # å½“æºä¸ºç™¾åº¦å­¦æœ¯æˆ–ä¸­å›½çŸ¥ç½‘æ—¶ï¼Œç›´æ¥åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€
        if source == "ç™¾åº¦å­¦æœ¯":
            url = f"https://xueshu.baidu.com/s?wd={quote_plus(query)}"
            self.root.after(0, lambda: self.paper_status_label.config(text="ç™¾åº¦å­¦æœ¯æœç´¢å°†åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€"))
            self.root.after(0, lambda: self.search_button.config(state="normal"))
            self.root.after(0, lambda: self.cancel_search_button.config(state="disabled"))
            self.root.after(0, lambda: self.search_progress.stop())
            webbrowser.open(url)
            return
        
        elif source == "ä¸­å›½çŸ¥ç½‘":
            url = f"https://kns.cnki.net/kns8/defaultresult/index?kw={quote_plus(query)}"
            self.root.after(0, lambda: self.paper_status_label.config(text="ä¸­å›½çŸ¥ç½‘æœç´¢å°†åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€"))
            self.root.after(0, lambda: self.search_button.config(state="normal"))
            self.root.after(0, lambda: self.cancel_search_button.config(state="disabled"))
            self.root.after(0, lambda: self.search_progress.stop())
            webbrowser.open(url)
            return
        
        try:
            # å¾ªç¯æ£€æŸ¥æ˜¯å¦åº”è¯¥å–æ¶ˆæœç´?
            def is_search_cancelled():
                return hasattr(self, 'cancel_search_flag') and self.cancel_search_flag

            # å»¶è¿Ÿå‡å°‘èµ„æºå†²çª
            time.sleep(0.1)
            
            # æ£€æŸ¥æ˜¯å¦éœ€è¦å–æ¶?
            if is_search_cancelled():
                self.root.after(0, lambda: self._handle_search_cancelled())
                return
                
            # è¿›è¡Œæœç´¢
            try:
                results, message = self.paper_downloader.search_papers(query, source)
            except Exception as e:
                self.root.after(0, lambda: self._handle_search_error(f"æœç´¢å‡ºé”™: {str(e)}"))
                return
                
            # å†æ¬¡æ£€æŸ¥æ˜¯å¦éœ€è¦å–æ¶?
            if is_search_cancelled():
                self.root.after(0, lambda: self._handle_search_cancelled())
                return
                
            # å¤„ç†æœç´¢è¿”å›ç»“æœ
            if isinstance(results, dict) and "error" in results:
                # å¤„ç†è¿”å›é”™è¯¯ä¿¡æ¯çš„æƒ…å†?
                error_message = results["error"]
                self.root.after(0, lambda: self._handle_search_error(error_message))
                return
                    
            elif isinstance(results, str):  
                # å¦‚æœè¿”å›çš„æ˜¯é”™è¯¯ä¿¡æ¯å­—ç¬¦ä¸?
                self.root.after(0, lambda: self._handle_search_error(results))
                return
                    
            if not results:
                self.root.after(0, lambda: self.paper_status_label.config(text=f"æœªæ‰¾åˆ°ä¸ '{query}' ç›¸å…³çš„è®ºæ–?))
                self.root.after(0, lambda: self.search_button.config(state="normal"))
                self.root.after(0, lambda: self.cancel_search_button.config(state="disabled"))
                self.root.after(0, lambda: self.search_progress.stop())
                return
                
            # æ›´æ–°UIæ˜¾ç¤ºæœç´¢ç»“æœ
            self.root.after(0, lambda: self._update_search_results(results, query, source))
            
        except Exception as e:
            import traceback
            logging.error(f"æœç´¢æ‰§è¡Œé”™è¯¯: {str(e)}")
            logging.error(traceback.format_exc())
            self.root.after(0, lambda: self._handle_search_error(f"æœç´¢å‡ºé”™: {str(e)}"))

    def _handle_search_cancelled(self):
        """å¤„ç†æœç´¢è¢«å–æ¶ˆçš„æƒ…å†µ"""
        self.paper_status_label.config(text="æœç´¢å·²å–æ¶?)
        self.search_button.config(state="normal")
        self.cancel_search_button.config(state="disabled")
        self.search_progress.stop()
        self.search_status_var.set("å°±ç»ª")
        
    def _handle_search_error(self, error_msg):
        """å¤„ç†æœç´¢è¿‡ç¨‹ä¸­çš„é”™è¯¯"""
        logging.error(f"æœç´¢é”™è¯¯: {error_msg}")
        self.search_button.config(state="normal")
        self.cancel_search_button.config(state="disabled")
        self.paper_status_label.config(text=f"æœç´¢å‡ºé”™: {error_msg}")
        self.search_progress.stop()
        self.search_status_var.set("å‡ºé”™")
        
        # å¦‚æœé”™è¯¯æ¶ˆæ¯è¿‡é•¿ï¼Œæˆªæ–­æ˜¾ç¤ºå¹¶åœ¨è¯¦æƒ…åŒºåŸŸæ˜¾ç¤ºå®Œæ•´ä¿¡æ?
        if len(error_msg) > 60:
            self.paper_status_label.config(text=f"æœç´¢å‡ºé”™: {error_msg[:60]}...")
            self.paper_details_text.delete(1.0, tk.END)
            self.paper_details_text.insert(tk.END, "æœç´¢å‡ºé”™\n\n", "title")
            self.paper_details_text.insert(tk.END, f"é”™è¯¯è¯¦æƒ…: {error_msg}\n\n")
            self.paper_details_text.insert(tk.END, "å»ºè®®:\n1. æ£€æŸ¥ç½‘ç»œè¿æ¥\n2. å°è¯•ä½¿ç”¨å…¶ä»–æœç´¢æº\n3. å¦‚ä½¿ç”¨Google Scholarï¼Œå¯èƒ½éœ€è¦ç§‘å­¦ä¸Šç½‘\n4. å°è¯•ä½¿ç”¨ç™¾åº¦å­¦æœ¯æˆ–ä¸­å›½çŸ¥ç½?)
        
        # æ˜¾ç¤ºé”™è¯¯æç¤ºå¯¹è¯æ¡?
        self.root.after(100, lambda: messagebox.showerror("æœç´¢é”™è¯¯", 
                                                       f"æœç´¢è¿‡ç¨‹ä¸­å‡ºé”?\n{error_msg}\n\nå»ºè®®å°è¯•ä½¿ç”¨ç™¾åº¦å­¦æœ¯æˆ–ä¸­å›½çŸ¥ç½‘æœç´?))
    
    def _update_search_results(self, results, query, source):
        """æ›´æ–°æœç´¢ç»“æœæ˜¾ç¤ºï¼ˆUIçº¿ç¨‹å®‰å…¨ï¼?""
        # æ¸…ç©ºå½“å‰ç»“æœåˆ—è¡¨
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        # å­˜å‚¨æœç´¢ç»“æœ
        self.paper_results = results
        
        # æ·»åŠ æœç´¢ç»“æœåˆ°æ ‘å½¢åˆ—è¡¨ï¼ˆåˆ†æ‰¹å¤„ç†ä»¥é¿å…ç•Œé¢å¡é¡¿ï¼‰
        def add_batch(start_idx, batch_size=5):
            end_idx = min(start_idx + batch_size, len(results))
            for i in range(start_idx, end_idx):
                paper = results[i]
                title = paper.get('title', 'Unknown Title')
                authors = paper.get('authors', 'Unknown Authors')
                year = paper.get('year', '')
                source_info = paper.get('source', 'Unknown Source')
                
                # æ’å…¥åˆ°æ ‘å½¢åˆ—è¡?
                self.results_tree.insert("", "end", values=(title, authors, year, source_info))
            
            # å¦‚æœè¿˜æœ‰æ›´å¤šç»“æœï¼Œå®‰æ’ä¸‹ä¸€æ‰¹å¤„ç?
            if end_idx < len(results):
                self.root.after(10, lambda: add_batch(end_idx, batch_size))
            else:
                # æ‰€æœ‰ç»“æœéƒ½å¤„ç†å®Œæ¯•
                self.search_button.config(state="normal")
        
        # å¼€å§‹åˆ†æ‰¹å¤„ç?
        add_batch(0)
        
        # æ›´æ–°çŠ¶æ€?
        self.paper_status_label.config(text=f"æ‰¾åˆ° {len(results)} ç¯‡ä¸ '{query}' ç›¸å…³çš„è®ºæ–?(æ¥æº: {source})")
        
        # é‡ç½®é€‰ä¸­çš„è®ºæ–?
        self.selected_paper = None
        
        # ç¦ç”¨ä¸‹è½½æŒ‰é’®
        self.download_button.config(state="disabled")
        self.open_browser_button.config(state="disabled")
        self.add_to_kb_button.config(state="disabled")
    
    def on_result_select(self, event):
        """å¤„ç†æœç´¢ç»“æœé€‰æ‹©äº‹ä»¶"""
        selection = self.results_tree.selection()
        if selection:
            item_id = selection[0]
            item_index = self.results_tree.index(item_id)
            
            if 0 <= item_index < len(self.paper_results):
                self.selected_paper = self.paper_results[item_index]
                
                # æ›´æ–°çŠ¶æ€æ ‡ç­?
                title = self.selected_paper.get('title', 'Unknown Title')
                self.paper_status_label.config(text=f"å·²é€‰æ‹©: {title}")
                
                # å¯ç”¨ä¸‹è½½æŒ‰é’®
                self.download_button.config(state="normal")
                self.open_browser_button.config(state="normal")
                self.add_to_kb_button.config(state="normal")
                
                # æ˜¾ç¤ºè®ºæ–‡æ‘˜è¦
                self.show_paper_details(self.selected_paper)
            else:
                self.selected_paper = None
                self.paper_status_label.config(text="æ— æ•ˆçš„é€‰æ‹©")
                
                # ç¦ç”¨æŒ‰é’®
                self.download_button.config(state="disabled")
                self.open_browser_button.config(state="disabled")
                self.add_to_kb_button.config(state="disabled")
                
                # æ¸…ç©ºæ‘˜è¦
                self.clear_paper_details()
        else:
            self.selected_paper = None
            
            # ç¦ç”¨æŒ‰é’®
            self.download_button.config(state="disabled")
            self.open_browser_button.config(state="disabled")
            self.add_to_kb_button.config(state="disabled")
            
            # æ¸…ç©ºæ‘˜è¦
            self.clear_paper_details()
    
    def download_selected_paper(self):
        """ä¸‹è½½é€‰ä¸­çš„è®ºæ–?""
        if not self.selected_paper:
            self.paper_status_label.config(text="è¯·å…ˆé€‰æ‹©ä¸€ç¯‡è®ºæ–?)
            return
        
        # è·å–PDFé“¾æ¥
        pdf_link = None
        direct_pdf_url = self.selected_paper.get('direct_pdf_url', '')
        arxiv_id = self.selected_paper.get('arxiv_id', '')
        doi = self.selected_paper.get('doi', '')
        
        # å¦‚æœæ˜¯DOIï¼Œä½¿ç”¨ä¸“é—¨çš„DOIä¸‹è½½é€»è¾‘
        if doi:
            if self.selected_paper.get('source') == 'Sci-Hub' or 'doi.org' in self.selected_paper.get('url', ''):
                self.download_by_doi(doi)
                return
        
        # å¦‚æœæ˜¯ArXivï¼Œä¼˜å…ˆä½¿ç”¨direct_pdf_url
        if arxiv_id:
            if direct_pdf_url:
                pdf_link = direct_pdf_url
            else:
                pdf_link = f"https://arxiv.org/pdf/{arxiv_id}.pdf"
        elif direct_pdf_url:
            pdf_link = direct_pdf_url
        else:
            # æŸ¥æ‰¾å…¶ä»–å¯èƒ½çš„PDFé“¾æ¥
            pdf_link = self.selected_paper.get('pdf_link', '')
            if not pdf_link:
                url = self.selected_paper.get('url', '')
                if url and url.lower().endswith('.pdf'):
                    pdf_link = url
        
        # å¦‚æœæ²¡æœ‰æ‰¾åˆ°PDFé“¾æ¥ï¼Œæç¤ºç”¨æˆ?
        if not pdf_link:
            self.paper_status_label.config(text="æ— æ³•æ‰¾åˆ°PDFä¸‹è½½é“¾æ¥ï¼Œè¯·å°è¯•åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€")
            return
        
        # è®¾ç½®PDFé“¾æ¥
        self.selected_paper['pdf_link'] = pdf_link
        
        # åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­æ‰§è¡Œä¸‹è½½ï¼Œé¿å…UIå†»ç»“
        download_thread = threading.Thread(target=self._execute_download)
        download_thread.daemon = True
        download_thread.start()
    
    def download_by_doi(self, doi):
        """é€šè¿‡DOIç›´æ¥ä¸‹è½½è®ºæ–‡"""
        if not doi:
            self.paper_status_label.config(text="æ— æ•ˆçš„DOI")
            return
            
        # ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨
        download_dir = "downloaded_papers"
        if not os.path.exists(download_dir):
            os.makedirs(download_dir)
            
        # æ›´æ–°UIçŠ¶æ€?
        self.paper_status_label.config(text=f"æ­£åœ¨é€šè¿‡DOIä¸‹è½½: {doi}...")
        self.doi_button.config(state="disabled", text="æ­£åœ¨ä¸‹è½½...")
        
        # åˆ›å»ºè®ºæ–‡æ•°æ®ç”¨äºå±•ç¤º
        mirrors = [
            "https://sci-hub.se",
            "https://sci-hub.ru",
            "https://sci-hub.st",
            "https://sci-hub.ren"
        ]
        
        # æ›´æ–°è¯¦æƒ…æ˜¾ç¤º
        self.paper_details_text.delete(1.0, tk.END)
        self.paper_details_text.insert(tk.END, f"æ­£åœ¨ä¸‹è½½ DOI: {doi}\n\n", "bold")
        self.paper_details_text.insert(tk.END, "æ¥æº: Sci-Hub\n\n")
        
        # æ·»åŠ å¤‡ç”¨é•œåƒé“¾æ¥
        self.paper_details_text.insert(tk.END, "å¤‡ç”¨Sci-Hubé•œåƒé“¾æ¥ (å¦‚æœè‡ªåŠ¨ä¸‹è½½å¤±è´¥ï¼Œå¯ç‚¹å‡»æ‰‹åŠ¨æ‰“å¼€):\n")
        for i, mirror in enumerate(mirrors):
            url = f"{mirror}/{doi}"
            tag_name = f"url={url}"
            self.paper_details_text.insert(tk.END, f"é•œåƒ {i+1}: ")
            self.paper_details_text.insert(tk.END, url, ("link", tag_name))
            self.paper_details_text.insert(tk.END, "\n")
        
        # ä½¿ç”¨çº¿ç¨‹è¿›è¡Œä¸‹è½½
        download_thread = threading.Thread(target=lambda: self._execute_doi_download(doi))
        download_thread.daemon = True
        download_thread.start()
    
    def _execute_doi_download(self, doi):
        """æ‰§è¡ŒDOIä¸‹è½½"""
        # é‡ç½®è¿›åº¦æ?
        self.root.after(0, lambda: self.download_progress.config(value=0))
        self.root.after(0, lambda: self.download_status.config(text="å‡†å¤‡é€šè¿‡DOIä¸‹è½½..."))
        
        # Sci-Hubé•œåƒåˆ—è¡¨ - æ›´æ–°é•œåƒåˆ—è¡¨
        success = False
        mirrors = ["sci-hub.se", "sci-hub.ru", "sci-hub.st", "sci-hub.ren", "sci-hub.ee", "sci-hub.wf"]
        
        # å‡†å¤‡æ–‡ä»¶åå’Œè·¯å¾„
        filename = f"DOI_{doi.replace('/', '_')}.pdf"
        filepath = os.path.join("downloaded_papers", filename)
        
        # å¦‚æœæ–‡ä»¶å·²å­˜åœ¨ï¼Œæ·»åŠ åºå·
        if os.path.exists(filepath):
            counter = 1
            while os.path.exists(filepath):
                filepath = os.path.join("downloaded_papers", f"DOI_{doi.replace('/', '_')}_{counter}.pdf")
                counter += 1
        
        # æ›´å®Œæ•´çš„è¯·æ±‚å¤?
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
            "Accept-Encoding": "gzip, deflate, br",
            "Connection": "keep-alive",
            "Upgrade-Insecure-Requests": "1",
            "Cache-Control": "max-age=0"
        }
        
        # å°è¯•æ¯ä¸ªé•œåƒ
        error_message = ""
        found_html_no_pdf = False
        
        for i, mirror in enumerate(mirrors):
            if success:
                break
                
            # è®¡ç®—åŸºç¡€è¿›åº¦å€¼ï¼ˆåŸºäºå½“å‰é•œåƒç´¢å¼•ï¼?
            base_progress = i * (100 // len(mirrors))  # å°†æ€»è¿›åº¦å‡åŒ€åˆ†é…åˆ°å„ä¸ªé•œåƒ?
            self.root.after(0, lambda p=base_progress: self.download_progress.config(value=p))
            self.root.after(0, lambda m=mirror: self.download_status.config(
                text=f"å°è¯•é•œåƒ {m}..."))
                
            # æ„å»ºURLå¹¶å°è¯•å¤šç§æ ¼å¼?
            url_formats = [
                f"https://{mirror}/{doi}",  # æ ‡å‡†æ ¼å¼
                f"https://{mirror}/doi/{doi}"  # æŸäº›é•œåƒä½¿ç”¨çš„æ ¼å¼?
            ]
            
            for url_format in url_formats:
                if success:
                    break
                    
                try:
                    # æ›´æ–°çŠ¶æ€?
                    self.root.after(0, lambda u=url_format: 
                        self.download_status.config(text=f"è¿æ¥åˆ?{u}..."))
                    
                    # è·å–é¡µé¢ï¼Œä½¿ç”¨æ›´é•¿çš„è¶…æ—¶æ—¶é—´
                    response = requests.get(url_format, headers=headers, timeout=30, allow_redirects=True)
                    
                    if response.status_code == 200:
                        # æ›´æ–°è¿›åº¦
                        progress_step = (100 // len(mirrors)) // 3  # æ¯ä¸ªé•œåƒè¿›åº¦çš„ä¸‰åˆ†ä¹‹ä¸€
                        self.root.after(0, lambda p=base_progress+progress_step: 
                            self.download_progress.config(value=p))
                        self.root.after(0, lambda: 
                            self.download_status.config(text=f"è§£æé¡µé¢å†…å®¹..."))
                        
                        # è§£æé¡µé¢å¯»æ‰¾PDF
                        from bs4 import BeautifulSoup
                        soup = BeautifulSoup(response.text, 'html.parser')
                        
                        # æŸ¥æ‰¾PDFå†…å®¹çš„å¤šç§æ–¹å¼?
                        pdf_src = None
                        
                        # 1. æŸ¥æ‰¾æ ‡å‡†PDF iframe
                        iframe = soup.find('iframe', id='pdf')
                        if iframe and iframe.has_attr('src'):
                            pdf_src = iframe['src']
                        
                        # 2. å¦‚æœæ²¡æ‰¾åˆ°iframeï¼ŒæŸ¥æ‰¾embedæ ‡ç­¾
                        if not pdf_src:
                            embed = soup.find('embed', attrs={'type': 'application/pdf'})
                            if embed and embed.has_attr('src'):
                                pdf_src = embed['src']
                        
                        # 3. å¦‚æœè¿˜æ²¡æ‰¾åˆ°ï¼ŒæŸ¥æ‰¾é“¾æ¥åˆ°PDFçš„aæ ‡ç­¾
                        if not pdf_src:
                            pdf_links = soup.select('a[href$=".pdf"]')
                            if pdf_links:
                                pdf_src = pdf_links[0]['href']
                        
                        # 4. æŸ¥æ‰¾åŒ…å«"ä¸‹è½½"æˆ?download"çš„æŒ‰é’?é“¾æ¥
                        if not pdf_src:
                            download_links = []
                            for a in soup.find_all('a'):
                                if a.get_text() and ('ä¸‹è½½' in a.get_text() or 'download' in a.get_text().lower()):
                                    if a.has_attr('href'):
                                        download_links.append(a['href'])
                            
                            if download_links:
                                pdf_src = download_links[0]
                        
                        # å¦‚æœæ‰¾åˆ°äº†PDFé“¾æ¥
                        if pdf_src:
                            # æ ¼å¼åŒ–PDF URL
                            if pdf_src.startswith('//'):
                                pdf_src = 'https:' + pdf_src
                            elif not pdf_src.startswith(('http://', 'https://')):
                                # ç¡®ä¿é“¾æ¥æ ¼å¼æ­£ç¡®
                                base_url = url_format
                                if '/' in base_url[8:]:  # è·³è¿‡ http(s)://
                                    base_url = '/'.join(base_url.split('/')[:-1]) + '/'
                                pdf_src = base_url + pdf_src.lstrip('/')
                            
                            # æ›´æ–°è¿›åº¦
                            self.root.after(0, lambda p=base_progress+2*progress_step: 
                                self.download_progress.config(value=p))
                            self.root.after(0, lambda src=pdf_src: 
                                self.download_status.config(text=f"æ‰¾åˆ°PDFé“¾æ¥ï¼Œå¼€å§‹ä¸‹è½? {src[:50]}..."))
                            
                            # è®¾ç½®é‡è¯•æœºåˆ¶ä¸‹è½½PDF
                            pdf_retry_count = 0
                            max_pdf_retries = 2
                            
                            while pdf_retry_count < max_pdf_retries and not success:
                                try:
                                    # ä¸‹è½½PDF
                                    with requests.get(pdf_src, headers=headers, stream=True, timeout=40) as pdf_response:
                                        if pdf_response.status_code == 200:
                                            content_type = pdf_response.headers.get('Content-Type', '').lower()
                                            
                                            # éªŒè¯æ˜¯å¦ä¸ºPDFå†…å®¹
                                            if 'application/pdf' in content_type or pdf_src.lower().endswith('.pdf'):
                                                # è·å–æ–‡ä»¶å¤§å°
                                                total_size = int(pdf_response.headers.get('content-length', 0))
                                                
                                                # ä¿å­˜æ–‡ä»¶
                                                with open(filepath, 'wb') as f:
                                                    downloaded = 0
                                                    for i, chunk in enumerate(pdf_response.iter_content(chunk_size=8192)):
                                                        if chunk:
                                                            f.write(chunk)
                                                            downloaded += len(chunk)
                                                            
                                                            # æ›´æ–°è¿›åº¦æ¡ï¼Œä½†ä¸è¦å¤ªé¢‘ç¹
                                                            if i % 10 == 0 and total_size > 0:
                                                                download_progress = base_progress + 2*progress_step + int((downloaded / total_size) * progress_step)
                                                                self.root.after(0, lambda p=download_progress: 
                                                                    self.download_progress.config(value=p))
                                                                self.root.after(0, lambda d=downloaded, t=total_size: 
                                                                    self.download_status.config(
                                                                        text=f"ä¸‹è½½ä¸? {d/1024/1024:.1f}MB / {t/1024/1024:.1f}MB"))
                                                
                                                # éªŒè¯æ–‡ä»¶
                                                if os.path.exists(filepath) and os.path.getsize(filepath) > 10000:  # ç¡®ä¿è‡³å°‘10KB
                                                    success = True
                                                    
                                                    # æ›´æ–°UIçŠ¶æ€?
                                                    self.root.after(0, lambda: self.download_progress.config(value=100))
                                                    self.root.after(0, lambda: self.download_status.config(
                                                        text=f"ä¸‹è½½å®Œæˆ!"))
                                                    self.root.after(0, lambda: self.paper_status_label.config(
                                                        text=f"è®ºæ–‡ä¸‹è½½æˆåŠŸï¼DOI: {doi}, å·²ä¿å­˜ä¸º: {os.path.basename(filepath)}"))
                                                    self.root.after(0, lambda: self.doi_button.config(
                                                        state="normal", text="é€šè¿‡DOIä¸‹è½½"))
                                                        
                                                    # åˆ·æ–°æ–‡ä»¶åˆ—è¡¨å¹¶é«˜äº®æ˜¾ç¤ºä¸‹è½½æ–‡ä»?
                                                    self.root.after(100, self.refresh_downloaded_files)
                                                    self.root.after(500, lambda: self._highlight_file(os.path.basename(filepath)))
                                                    
                                                    # ä¸‹è½½æˆåŠŸï¼Œè¿”å›ç»“æ?
                                                    return {
                                                        "success": True,
                                                        "message": f"è®ºæ–‡ DOI:{doi} ä¸‹è½½æˆåŠŸ",
                                                        "file_path": filepath
                                                    }
                                                else:
                                                    # æ–‡ä»¶ä¸‹è½½å¤±è´¥æˆ–æŸå?
                                                    if os.path.exists(filepath):
                                                        os.remove(filepath)
                                                    error_message = f"ä»?{mirror} ä¸‹è½½çš„æ–‡ä»¶å¯èƒ½å·²æŸåæˆ–è¿‡å°?
                                            else:
                                                # ä¸æ˜¯PDFå†…å®¹
                                                error_message = f"ä»?{mirror} è·å–çš„å†…å®¹ä¸æ˜¯PDF (ç±»å‹: {content_type})"
                                        else:
                                            error_message = f"ä»?{mirror} ä¸‹è½½PDFå¤±è´¥ï¼ŒçŠ¶æ€ç : {pdf_response.status_code}"
                                except Exception as e:
                                    error_message = f"ä»?{mirror} ä¸‹è½½PDFå‡ºé”™: {str(e)}"
                                
                                pdf_retry_count += 1
                                if pdf_retry_count < max_pdf_retries and not success:
                                    time.sleep(2)  # é‡è¯•å‰ç­‰å¾?
                        else:
                            # æ²¡æœ‰æ‰¾åˆ°PDF iframe
                            found_html_no_pdf = True
                            error_message = f"{mirror} è¿”å›äº†é¡µé¢ï¼Œä½†æœªæ‰¾åˆ°PDFä¸‹è½½é“¾æ¥"
                    else:
                        # è¯·æ±‚å¤±è´¥
                        error_message = f"è¿æ¥ {mirror} å¤±è´¥ï¼ŒçŠ¶æ€ç : {response.status_code}"
                except requests.exceptions.SSLError:
                    error_message = f"{mirror} SSLè¯ä¹¦éªŒè¯å¤±è´¥"
                except requests.exceptions.ConnectionError:
                    error_message = f"è¿æ¥ {mirror} å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ?
                except requests.exceptions.Timeout:
                    error_message = f"è¿æ¥ {mirror} è¶…æ—¶ï¼Œè¯·ç¨åå†è¯•"
                except Exception as e:
                    # æ•è·å¼‚å¸¸
                    error_message = f"ä»?{mirror} ä¸‹è½½æ—¶å‡ºé”? {str(e)}"
        
        # æ‰€æœ‰é•œåƒéƒ½å°è¯•å¤±è´¥
        self.root.after(0, lambda: self.download_progress.config(value=0))
        self.root.after(0, lambda: self.download_status.config(text="ä¸‹è½½å¤±è´¥"))
        self.root.after(0, lambda: self.paper_status_label.config(
            text=f"æ— æ³•é€šè¿‡DOIä¸‹è½½è®ºæ–‡: {error_message}"))
        self.root.after(0, lambda: self.doi_button.config(
            state="normal", text="é€šè¿‡DOIä¸‹è½½"))
            
        # æ„å»ºæ›¿ä»£é“¾æ¥
        alternative_mirrors = []
        for mirror in mirrors:
            alternative_mirrors.append(f"https://{mirror}/{doi}")
            
        # æ·»åŠ å…¶ä»–å¯èƒ½çš„æ¥æºé“¾æ?
        alternative_mirrors.append(f"https://doi.org/{doi}")  # å®˜æ–¹DOIè§£æå™?
        alternative_mirrors.append(f"https://www.crossref.org/openurl?pid=youremail@example.com&id=doi:{doi}")
        
        # è¿”å›å¤±è´¥ç»“æœ
        return {
            "success": False, 
            "message": f"æ— æ³•é€šè¿‡DOIä¸‹è½½è®ºæ–‡: {error_message}",
            "alternative_links": alternative_mirrors
        }
    
    def _execute_download(self):
        """åœ¨å•ç‹¬çº¿ç¨‹ä¸­æ‰§è¡Œä¸‹è½½ï¼Œé¿å…UIå†»ç»“"""
        try:
            # æ¸…é™¤è¿›åº¦æ¡å’Œæ›´æ–°çŠ¶æ€?
            self.download_progress["value"] = 0
            self.download_button.config(state="disabled")
            self.paper_status_label.config(text="å‡†å¤‡ä¸‹è½½...")
            
            # æ£€æŸ¥PDFé“¾æ¥æ˜¯å¦å­˜åœ¨
            pdf_link = self.selected_paper.get('pdf_link', '')
            if not pdf_link:
                self.paper_status_label.config(text="æ— æ³•æ‰¾åˆ°PDFé“¾æ¥ï¼Œä¸‹è½½å¤±è´?)
                self.download_button.config(state="normal")
                return
                
            # æ¸…ç†æ–‡ä»¶åä¸­çš„éæ³•å­—ç¬?
            def clean_filename(name):
                name = re.sub(r'[\\/*?:"<>|]', "_", name)
                return name.strip()
            
            # æ ¹æ®é€‰ä¸­çš„è®ºæ–‡è®¾ç½®æ–‡ä»¶å
            title = self.selected_paper.get('title', 'unknown_paper')
            # ç§»é™¤æ–‡ä»¶åä¸­ä¸åˆæ³•çš„å­—ç¬¦
            clean_title = clean_filename(title)
            # å¦‚æœæ–‡ä»¶åè¿‡é•¿ï¼Œæˆªæ–­å®?
            if len(clean_title) > 100:
                clean_title = clean_title[:100]
            
            # è®¾ç½®ä¿å­˜ç›®å½•
            if not os.path.exists(self.papers_dir):
                os.makedirs(self.papers_dir)
                
            # æ„å»ºæ–‡ä»¶è·¯å¾„
            file_path = os.path.join(self.papers_dir, f"{clean_title}.pdf")
            
            # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
            if os.path.exists(file_path):
                counter = 1
                while os.path.exists(file_path):
                    file_path = os.path.join(self.papers_dir, f"{clean_title}_{counter}.pdf")
                    counter += 1
            
            # æ›´æ–°UIçŠ¶æ€?
            self.paper_status_label.config(text=f"æ­£åœ¨ä»?{pdf_link} ä¸‹è½½...")
            self.download_progress.start(10)  # åŠ¨ç”»æ•ˆæœ
            
            # é…ç½®è¯·æ±‚å¤?- æ›´å…¨é¢çš„è¯·æ±‚å¤´é…ç½?
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7',
                'Accept-Encoding': 'gzip, deflate, br',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Cache-Control': 'max-age=0',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Sec-Fetch-User': '?1',
                'DNT': '1'
            }
            
            # æ‰§è¡Œä¸‹è½½ - æ”¹è¿›é”™è¯¯å¤„ç†å’Œé‡è¯•é€»è¾‘
            max_retries = 3
            retry_count = 0
            success = False
            error_message = ""
            
            while retry_count < max_retries and not success:
                try:
                    # å…è®¸é‡å®šå?
                    response = requests.get(
                        pdf_link, 
                        headers=headers, 
                        stream=True, 
                        timeout=45,  # å¢åŠ è¶…æ—¶æ—¶é—´
                        allow_redirects=True  # ç¡®ä¿è·Ÿéšé‡å®šå?
                    )
                    
                    # è®°å½•æœ€ç»ˆURLï¼ˆå¤„ç†é‡å®šå‘åï¼‰
                    final_url = response.url
                    
                    if response.status_code == 200:
                        # æ£€æŸ¥å†…å®¹ç±»å?
                        content_type = response.headers.get('Content-Type', '').lower()
                        
                        # å¤„ç†PDFå†…å®¹
                        if 'application/pdf' in content_type or pdf_link.lower().endswith('.pdf') or final_url.lower().endswith('.pdf'):
                            # è·å–æ€»æ–‡ä»¶å¤§å°?
                            total_size = int(response.headers.get('content-length', 0))
                            downloaded = 0
                            
                            # ä¿å­˜PDFæ–‡ä»¶
                            with open(file_path, 'wb') as f:
                                self.download_progress.stop()  # åœæ­¢ä¸ç¡®å®šè¿›åº¦åŠ¨ç”?
                                
                                for i, chunk in enumerate(response.iter_content(chunk_size=8192)):
                                    if chunk:
                                        f.write(chunk)
                                        downloaded += len(chunk)
                                        
                                        # æ›´æ–°è¿›åº¦æ?
                                        if i % 5 == 0 and total_size > 0:
                                            progress = int((downloaded / total_size) * 100)
                                            self.download_progress["value"] = progress
                                            self.download_status.config(
                                                text=f"ä¸‹è½½ä¸? {downloaded/1024/1024:.1f}MB / {total_size/1024/1024:.1f}MB"
                                            )
                                            # å…è®¸UIæ›´æ–°
                                            self.root.update_idletasks()
                            
                            # éªŒè¯ä¸‹è½½çš„æ–‡ä»?
                            if os.path.exists(file_path) and os.path.getsize(file_path) > 1024:  # è‡³å°‘1KB
                                success = True
                                
                                # æ›´æ–°çŠ¶æ€?
                                self.download_progress["value"] = 100
                                self.paper_status_label.config(text=f"ä¸‹è½½å®Œæˆ: {os.path.basename(file_path)}")
                                self.download_status.config(text="ä¸‹è½½æˆåŠŸ!")
                                
                                # è®°å½•ä¸‹è½½è·¯å¾„ä»¥ä¾›åç»­ä½¿ç”¨
                                self.last_download_path = file_path
                                
                                # åˆ·æ–°ä¸‹è½½åˆ—è¡¨
                                self.refresh_downloaded_files()
                                self._highlight_file(os.path.basename(file_path))
                            else:
                                # æ–‡ä»¶æŸåæˆ–å¤ªå°?
                                if os.path.exists(file_path):
                                    os.remove(file_path)
                                error_message = "ä¸‹è½½çš„æ–‡ä»¶å¯èƒ½å·²æŸåæˆ–ä¸å®Œæ•´"
                        else:
                            # å¤„ç†HTMLå“åº” - å°è¯•ä»ä¸­æå–PDFé“¾æ¥
                            soup = BeautifulSoup(response.text, 'html.parser')
                            
                            # å°è¯•å¯»æ‰¾é¡µé¢ä¸Šçš„PDFé“¾æ¥
                            pdf_links = soup.select('a[href$=".pdf"]')
                            if pdf_links:
                                new_pdf_link = pdf_links[0]['href']
                                # å¦‚æœæ˜¯ç›¸å¯¹é“¾æ¥ï¼Œè½¬ä¸ºç»å¯¹é“¾æ¥
                                if not new_pdf_link.startswith(('http://', 'https://')):
                                    base_url = response.url
                                    if '/' in base_url[8:]:  # è·³è¿‡ http(s)://
                                        base_url = '/'.join(base_url.split('/')[:-1]) + '/'
                                    new_pdf_link = base_url + new_pdf_link.lstrip('/')
                                
                                # æ›´æ–°é“¾æ¥å¹¶é‡è¯?
                                pdf_link = new_pdf_link
                                retry_count += 1
                                self.paper_status_label.config(text=f"æ‰¾åˆ°æ–°çš„PDFé“¾æ¥ï¼Œå°è¯•ä¸‹è½? {pdf_link}")
                                continue
                            
                            # æ²¡æœ‰æ‰¾åˆ°PDFé“¾æ¥
                            error_message = f"å“åº”å†…å®¹ä¸æ˜¯PDFæ–‡ä»¶ (ç±»å‹: {content_type})"
                            
                            # å¦‚æœçœ‹èµ·æ¥æ˜¯å­¦æœ¯ç½‘ç«™çš„ç™»å½•é¡µé¢ï¼Œæç¤ºç”¨æˆ·
                            if 'ç™»å½•' in response.text or 'login' in response.text.lower() or 'sign in' in response.text.lower():
                                error_message = "éœ€è¦ç™»å½•æ‰èƒ½è®¿é—®æ­¤å†…å®¹ï¼Œè¯·å°è¯•åœ¨æµè§ˆå™¨ä¸­æ‰‹åŠ¨æ‰“å¼€"
                    else:
                        # å¤„ç†HTTPé”™è¯¯
                        if response.status_code == 403:
                            error_message = "è®¿é—®è¢«æ‹’ç»?(403 Forbidden)ï¼Œå¯èƒ½éœ€è¦ç™»å½•æˆ–è®¿é—®æƒé™"
                        elif response.status_code == 404:
                            error_message = "æœªæ‰¾åˆ°èµ„æº?(404 Not Found)ï¼Œé“¾æ¥å¯èƒ½å·²å¤±æ•ˆ"
                        elif response.status_code == 429:
                            error_message = "è¯·æ±‚è¿‡å¤š (429 Too Many Requests)ï¼Œè¯·ç¨åå†è¯•"
                        elif 500 <= response.status_code < 600:
                            error_message = f"æœåŠ¡å™¨é”™è¯?({response.status_code})ï¼Œè¯·ç¨åå†è¯•"
                        else:
                            error_message = f"HTTPé”™è¯¯: {response.status_code}"
                
                except requests.exceptions.SSLError:
                    error_message = "SSLè¯ä¹¦éªŒè¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½?
                except requests.exceptions.ConnectionError:
                    error_message = "è¿æ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ?
                except requests.exceptions.Timeout:
                    error_message = "è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åå†è¯•"
                except requests.exceptions.TooManyRedirects:
                    error_message = "é‡å®šå‘è¿‡å¤šï¼Œè¯·ç¨åå†è¯?
                except requests.exceptions.RequestException as e:
                    error_message = f"è¯·æ±‚é”™è¯¯: {str(e)}"
                except Exception as e:
                    error_message = f"ä¸‹è½½è¿‡ç¨‹ä¸­å‡ºé”? {str(e)}"
                
                retry_count += 1
                if retry_count < max_retries and not success:
                    self.paper_status_label.config(text=f"ä¸‹è½½å¤±è´¥ï¼Œæ­£åœ¨é‡è¯?({retry_count}/{max_retries})...")
                    time.sleep(2)  # é‡è¯•å‰ç­‰å¾?ç§?
            
            # å¦‚æœæ‰€æœ‰å°è¯•éƒ½å¤±è´¥
            if not success:
                self.download_progress.stop()
                self.paper_status_label.config(text=f"ä¸‹è½½å¤±è´¥: {error_message}")
                
                # å°è¯•åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€
                try:
                    import webbrowser
                    # å¦‚æœæ˜¯PDFé“¾æ¥ï¼Œç›´æ¥æ‰“å¼€
                    url_to_open = pdf_link
                    # å¦‚æœä¸æ˜¯PDFï¼Œå°è¯•æ‰¾åˆ°æ›´åˆé€‚çš„URLæ‰“å¼€
                    if not pdf_link.lower().endswith('.pdf'):
                        url_to_open = self.selected_paper.get('url', '') or pdf_link
                    
                    # ç¡®è®¤æ‰“å¼€æµè§ˆå™?
                    if messagebox.askyesno("ä¸‹è½½å¤±è´¥", 
                                         f"ä¸‹è½½å¤±è´¥: {error_message}\n\næ˜¯å¦åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€é“¾æ¥å°è¯•æ‰‹åŠ¨ä¸‹è½½?"):
                        webbrowser.open(url_to_open)
                        self.paper_status_label.config(text="å·²åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€é“¾æ¥")
                except Exception as e:
                    self.paper_status_label.config(text=f"æ— æ³•æ‰“å¼€æµè§ˆå™? {str(e)}")
            
            # æ¢å¤æŒ‰é’®çŠ¶æ€?
            self.download_button.config(state="normal")
            
        except Exception as e:
            # å¤„ç†ä»»ä½•å…¶ä»–å¼‚å¸¸
            self.paper_status_label.config(text=f"ä¸‹è½½è¿‡ç¨‹ä¸­å‡ºç°æ„å¤–é”™è¯? {str(e)}")
            self.download_progress.stop()
            self.download_button.config(state="normal")
    
    def refresh_downloaded_files(self):
        """åˆ·æ–°å·²ä¸‹è½½æ–‡ä»¶åˆ—è¡?""
        try:
            # æ¸…ç©ºå½“å‰åˆ—è¡¨
            self.downloaded_files_list.delete(0, tk.END)
            
            # æ£€æŸ¥ä¸‹è½½ç›®å½•æ˜¯å¦å­˜åœ?
            if not os.path.exists(self.papers_dir):
                os.makedirs(self.papers_dir)
                return
            
            # è·å–æ‰€æœ‰PDFæ–‡ä»¶
            pdf_files = [f for f in os.listdir(self.papers_dir) 
                        if f.lower().endswith('.pdf')]
            
            # æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼?
            pdf_files.sort(key=lambda x: os.path.getmtime(os.path.join(self.papers_dir, x)), 
                          reverse=True)
            
            # æ·»åŠ åˆ°åˆ—è¡?
            for pdf_file in pdf_files:
                self.downloaded_files_list.insert(tk.END, pdf_file)
                
            # æ›´æ–°çŠ¶æ€?
            self.paper_status_label.config(text=f"æ‰¾åˆ° {len(pdf_files)} ä¸ªå·²ä¸‹è½½çš„PDFæ–‡ä»¶")
            
        except Exception as e:
            self.paper_status_label.config(text=f"åˆ·æ–°æ–‡ä»¶åˆ—è¡¨æ—¶å‡ºé”? {str(e)}")

    def _handle_download_result(self, result):
        """å¤„ç†ä¸‹è½½ç»“æœï¼Œæ›´æ–°UI"""
        # æ¢å¤UIçŠ¶æ€?
        self.download_progress.stop()
        self.download_button.config(state="normal")
        
        if result["success"]:
            # ä¸‹è½½æˆåŠŸ
            self.paper_status_label.config(text=result["message"])
            
            # ä¿å­˜æœ€åä¸‹è½½çš„æ–‡ä»¶è·¯å¾„
            self.last_download_path = result.get("file_path", "")
            
            # åˆ·æ–°æ–‡ä»¶åˆ—è¡¨å¹¶é«˜äº®æ–°ä¸‹è½½çš„æ–‡ä»?
            self.refresh_downloaded_files()
            if "file_path" in result:
                self._highlight_file(os.path.basename(result["file_path"]))
        else:
            # ä¸‹è½½å¤±è´¥
            self.paper_status_label.config(text=result["message"])
            
            # å¦‚æœæœ‰æ›¿ä»£é“¾æ¥å»ºè®®ï¼Œæ˜¾ç¤ºå®ƒä»¬
            alternative_links = result.get("alternative_links", [])
            if alternative_links:
                links_text = "\n".join(alternative_links)
                message = f"ä¸‹è½½å¤±è´¥ã€‚è¯·å°è¯•ä»¥ä¸‹é“¾æ¥:\n{links_text}"
                self.show_message("ä¸‹è½½å¤±è´¥", message)
    
    def on_file_select(self, event):
        """å¤„ç†æ–‡ä»¶é€‰æ‹©äº‹ä»¶"""
        try:
            # è·å–é€‰ä¸­é¡?
            selection = self.downloaded_files_list.curselection()
            if not selection:
                return
                
            # è·å–æ–‡ä»¶å?
            index = selection[0]
            filename = self.downloaded_files_list.get(index)
            
            # æ›´æ–°çŠ¶æ€æ ‡ç­?
            file_path = os.path.join(self.papers_dir, filename)
            file_size = os.path.getsize(file_path) / 1024  # KB
            
            # æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
            if file_size > 1024:
                size_str = f"{file_size/1024:.2f} MB"
            else:
                size_str = f"{file_size:.2f} KB"
                
            # æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
            self.paper_status_label.config(text=f"å·²é€‰æ‹©: {filename} ({size_str})")
            
        except Exception as e:
            self.paper_status_label.config(text=f"æ— æ³•è·å–æ–‡ä»¶ä¿¡æ¯: {str(e)}")

    def on_file_double_click(self, event):
        """åŒå‡»æ–‡ä»¶æ—¶çš„å¤„ç†"""
        try:
            self.open_selected_file()
        except Exception as e:
            self.paper_status_label.config(text=f"æ‰“å¼€æ–‡ä»¶æ—¶å‡ºé”? {str(e)}")
    
    def open_selected_file(self):
        """æ‰“å¼€å½“å‰é€‰ä¸­çš„æ–‡ä»?""
        # è·å–é€‰ä¸­çš„æ–‡ä»?
        selection = self.downloaded_files_list.curselection()
        if not selection:
            self.paper_status_label.config(text="è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»?)
            return
            
        # è·å–æ–‡ä»¶è·¯å¾„
        index = selection[0]
        filename = self.downloaded_files_list.get(index)
        file_path = os.path.join(self.papers_dir, filename)
        
        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ?
        if not os.path.exists(file_path):
            self.paper_status_label.config(text="æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·åˆ·æ–°åˆ—è¡?)
            return
            
        # è°ƒç”¨æ‰“å¼€æ–‡ä»¶æ–¹æ³•
        self.open_file(file_path)
    
    def open_file(self, file_path):
        """æ ¹æ®æ“ä½œç³»ç»Ÿæ‰“å¼€æ–‡ä»¶"""
        try:
            if sys.platform.startswith('win'):
                os.startfile(file_path)
            elif sys.platform.startswith('darwin'):  # macOS
                subprocess.call(['open', file_path])
            else:  # Linux
                subprocess.call(['xdg-open', file_path])
        except Exception as e:
            self.paper_status_label.config(text=f"æ— æ³•æ‰“å¼€æ–‡ä»¶: {str(e)}")
    
    def open_papers_folder(self):
        """æ‰“å¼€è®ºæ–‡ä¸‹è½½æ–‡ä»¶å¤?""
        try:
            papers_dir = self.paper_downloader.papers_dir
            
            if not os.path.exists(papers_dir):
                os.makedirs(papers_dir)
            
            self.open_file(papers_dir)
            self.paper_status_label.config(text=f"å·²æ‰“å¼€ä¸‹è½½æ–‡ä»¶å¤?)
        except Exception as e:
            self.paper_status_label.config(text=f"æ‰“å¼€æ–‡ä»¶å¤¹å‡ºé”? {str(e)}")
    
    def send_message(self, event=None):
        message = self.user_input.get("1.0", tk.END).strip()
        if not message:
            return
        
        # æ¸…ç©ºè¾“å…¥
        self.user_input.delete("1.0", tk.END)
        
        # æ›´æ–°å¯¹è¯å†å²
        self.chat_history.config(state=tk.NORMAL)
        self.chat_history.insert(tk.END, "ç”¨æˆ·: " + message + "\n\n")
        
        # æ·»åŠ åˆ°å†å²æ•°æ?
        self.chat_history_data.append({"user": message})
        
        # è°ƒç”¨AI API
        self.chat_history.insert(tk.END, "AIåŠ©æ‰‹: æ­£åœ¨æ€è€?..\n\n")
        self.chat_history.see(tk.END)
        self.chat_history.config(state=tk.DISABLED)
        
        # å¯åŠ¨çº¿ç¨‹å¤„ç†APIè¯·æ±‚
        Thread(target=self.process_api_request, args=(message,)).start()
    
    def process_api_request(self, message):
        # è·å–é€‰æ‹©çš„APIç±»å‹
        api_type = self.api_var.get()
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦ä½¿ç”¨çŸ¥è¯†åº“å¢å¼º
        use_knowledge = hasattr(self, 'use_knowledge_var') and self.use_knowledge_var.get()
        knowledge_context = ""
        
        if use_knowledge:
            # ä»çŸ¥è¯†åº“è·å–ç›¸å…³ä¸Šä¸‹æ–?
            knowledge_context = self.knowledge_manager.get_knowledge_context(message)
            if knowledge_context:
                # å°†çŸ¥è¯†åº“ä¸Šä¸‹æ–‡åŠ å…¥åˆ°æç¤ºä¸?
                message = knowledge_context + "\n\nåŸºäºä»¥ä¸ŠçŸ¥è¯†åº“ä¿¡æ¯ï¼Œè¯·å›ç­? " + message
        
        # è°ƒç”¨API
        response = self.api_manager.call_api(api_type, message, self.chat_history_data)
        
        # æ·»åŠ åˆ°å†å²æ•°æ?
        self.chat_history_data.append({"assistant": response})
        
        # æ›´æ–°å¯¹è¯å†å²
        self.chat_history.config(state=tk.NORMAL)
        # åˆ é™¤"æ­£åœ¨æ€è€?.."
        self.chat_history.delete(float(self.chat_history.index(tk.END)) - 3.0, tk.END)
        # æ·»åŠ å›å¤
        self.chat_history.insert(tk.END, "AIåŠ©æ‰‹: " + response + "\n\n")
        self.chat_history.see(tk.END)
        self.chat_history.config(state=tk.DISABLED)
    
    def clear_chat(self):
        self.chat_history.config(state=tk.NORMAL)
        self.chat_history.delete("1.0", tk.END)
        self.chat_history.config(state=tk.DISABLED)
    
    def upload_to_knowledge_base(self):
        files = filedialog.askopenfilenames(title="é€‰æ‹©æ–‡ä»¶ä¸Šä¼ åˆ°çŸ¥è¯†åº“", 
                                          filetypes=[("æ–‡æœ¬æ–‡ä»¶", "*.txt"), 
                                                     ("PDFæ–‡ä»¶", "*.pdf"),
                                                     ("Wordæ–‡ä»¶", "*.docx"),
                                                     ("æ‰€æœ‰æ–‡ä»?, "*.*")])
        if files:
            # åˆ›å»ºçŸ¥è¯†åº“ç›®å½?
            os.makedirs("knowledge_base", exist_ok=True)
            
            for file in files:
                # æ‹·è´æ–‡ä»¶åˆ°çŸ¥è¯†åº“
                import shutil
                filename = os.path.basename(file)
                destination = os.path.join("knowledge_base", filename)
                shutil.copy2(file, destination)
            
            messagebox.showinfo("ä¸Šä¼ æˆåŠŸ", f"å·²ä¸Šä¼?{len(files)} ä¸ªæ–‡ä»¶åˆ°çŸ¥è¯†åº?)
            self.refresh_knowledge_list()
    
    def manage_knowledge_base(self):
        if not os.path.exists("knowledge_base"):
            messagebox.showinfo("æç¤º", "çŸ¥è¯†åº“ä¸ºç©?)
            return
            
        selected = self.knowledge_list.curselection()
        if not selected:
            messagebox.showinfo("æç¤º", "è¯·å…ˆé€‰æ‹©æ–‡ä»¶")
            return
            
        file = self.knowledge_list.get(selected[0])
        answer = messagebox.askyesno("ç¡®è®¤", f"æ˜¯å¦åˆ é™¤æ–‡ä»¶ {file}?")
        if answer:
            os.remove(os.path.join("knowledge_base", file))
            self.refresh_knowledge_list()
    
    def refresh_knowledge_list(self):
        """åˆ·æ–°çŸ¥è¯†åº“æ–‡ä»¶åˆ—è¡?""
        # æ¸…ç©ºå½“å‰åˆ—è¡¨
        self.knowledge_list.delete(0, tk.END)
        
        # è·å–é€‰ä¸­çš„åˆ†åŒ?
        category = self.selected_category.get()
        
        # è·å–æ–‡ä»¶åˆ—è¡¨
        if category == "å…¨éƒ¨":
            files = self.knowledge_manager.get_files_by_category()
        else:
            files = self.knowledge_manager.get_files_by_category(category)
        
        # ç”¨äºä¿å­˜æ–‡ä»¶IDæ˜ å°„
        self.knowledge_files_map = {}
        
        # æ·»åŠ æ–‡ä»¶åˆ°åˆ—è¡¨ä¸­
        if files:
            for i, file_info in enumerate(files):
                display_name = file_info.get('title', file_info.get('filename', 'æœªçŸ¥æ–‡ä»¶'))
                # å­˜å‚¨æ–‡ä»¶IDåˆ°æ˜ å°„ä¸­
                self.knowledge_list.insert(tk.END, display_name)
                # å­˜å‚¨æ–‡ä»¶IDåˆ°å­—å…¸ä¸­ï¼Œä»¥ç´¢å¼•ä¸ºé”®
                self.knowledge_files_map[i] = file_info.get('file_id')
        else:
            self.knowledge_list.insert(tk.END, f"{'å½“å‰åˆ†åŒºä¸ºç©º' if category != 'å…¨éƒ¨' else 'çŸ¥è¯†åº“ä¸ºç©?}")
        
        # æ¸…ç©ºè¯¦æƒ…å’Œé¢„è§?
        self.clear_file_details()
        
        # ç¦ç”¨åˆ é™¤æŒ‰é’®
        self.delete_button.config(state="disabled")
    
    def on_knowledge_file_select(self, event):
        """å¤„ç†çŸ¥è¯†åº“æ–‡ä»¶é€‰æ‹©äº‹ä»¶"""
        # è·å–é€‰ä¸­çš„ç´¢å¼?
        selection = self.knowledge_list.curselection()
        if not selection:
            return
        
        index = selection[0]
        # è·å–æ–‡ä»¶ID
        try:
            # ä»å­—å…¸ä¸­è·å–æ–‡ä»¶ID
            file_id = self.knowledge_files_map.get(index)
            if not file_id:
                # å¦‚æœæ²¡æœ‰æ–‡ä»¶IDï¼Œå¯èƒ½æ˜¯ç©ºæç¤ºä¿¡æ?
                self.clear_file_details()
                return
                
            # è·å–æ–‡ä»¶ä¿¡æ¯
            file_info = self.knowledge_manager.get_file_info(file_id)
            if not file_info:
                self.clear_file_details()
                return
                
            # æ›´æ–°è¯¦æƒ…æ˜¾ç¤º
            self.file_title_label.config(text=f"æ ‡é¢˜: {file_info.get('title', 'æœªçŸ¥')}")
            self.file_authors_label.config(text=f"ä½œè€? {file_info.get('authors', 'æœªçŸ¥')}")
            self.file_year_label.config(text=f"å¹´ä»½: {file_info.get('year', 'æœªçŸ¥')}")
            self.file_category_label.config(text=f"åˆ†åŒº: {file_info.get('category', 'å…¶ä»–')}")
            self.file_path_label.config(text=f"è·¯å¾„: {file_info.get('path', 'æœªçŸ¥')}")
            
            # å°è¯•æ˜¾ç¤ºé¢„è§ˆ
            self.load_file_preview(file_info)
            
            # å¯ç”¨åˆ é™¤æŒ‰é’®
            self.delete_button.config(state="normal")
        except Exception as e:
            print(f"æ–‡ä»¶é€‰æ‹©å‡ºé”™: {str(e)}")
            self.clear_file_details()
    
    def clear_file_details(self):
        """æ¸…ç©ºæ–‡ä»¶è¯¦æƒ…å’Œé¢„è§?""
        self.file_title_label.config(text="æ ‡é¢˜: ")
        self.file_authors_label.config(text="ä½œè€? ")
        self.file_year_label.config(text="å¹´ä»½: ")
        self.file_category_label.config(text="åˆ†åŒº: ")
        self.file_path_label.config(text="è·¯å¾„: ")
        self.preview_text.delete(1.0, tk.END)
    
    def load_file_preview(self, file_info):
        """åŠ è½½æ–‡ä»¶é¢„è§ˆ"""
        self.preview_text.delete(1.0, tk.END)
        
        # å°è¯•åŠ è½½æ–‡ä»¶æ‘˜è¦æˆ–å†…å®?
        if 'abstract' in file_info and file_info['abstract']:
            self.preview_text.insert(tk.END, "æ‘˜è¦:\n", "heading")
            self.preview_text.insert(tk.END, file_info['abstract'] + "\n\n")
        
        if 'summary' in file_info and file_info['summary']:
            self.preview_text.insert(tk.END, "æ¦‚è¦:\n", "heading")
            self.preview_text.insert(tk.END, file_info['summary'] + "\n\n")
        
        # é…ç½®æ ·å¼
        self.preview_text.tag_configure("heading", font=("Arial", 10, "bold"))
    
    def open_knowledge_file(self, event):
        """æ‰“å¼€é€‰ä¸­çš„çŸ¥è¯†åº“æ–‡ä»¶"""
        # è·å–é€‰ä¸­çš„ç´¢å¼?
        selection = self.knowledge_list.curselection()
        if not selection:
            return
        
        index = selection[0]
        # è·å–æ–‡ä»¶ID
        try:
            # ä»å­—å…¸ä¸­è·å–æ–‡ä»¶ID
            file_id = self.knowledge_files_map.get(index)
            if not file_id:
                return
                
            # è·å–æ–‡ä»¶ä¿¡æ¯
            file_info = self.knowledge_manager.get_file_info(file_id)
            if not file_info or 'path' not in file_info:
                return
                
            # æ‰“å¼€æ–‡ä»¶
            self.open_file(file_info['path'])
        except Exception as e:
            print(f"æ‰“å¼€æ–‡ä»¶å‡ºé”™: {str(e)}")
    
    def delete_from_knowledge_base(self):
        """ä»çŸ¥è¯†åº“ä¸­åˆ é™¤é€‰ä¸­æ–‡ä»¶"""
        # è·å–é€‰ä¸­çš„ç´¢å¼?
        selection = self.knowledge_list.curselection()
        if not selection:
            return
        
        index = selection[0]
        # è·å–æ–‡ä»¶ID
        try:
            # ä»å­—å…¸ä¸­è·å–æ–‡ä»¶ID
            file_id = self.knowledge_files_map.get(index)
            if not file_id:
                return
                
            # ç¡®è®¤åˆ é™¤
            if not messagebox.askyesno("ç¡®è®¤åˆ é™¤", "ç¡®å®šè¦ä»çŸ¥è¯†åº“ä¸­åˆ é™¤æ­¤æ–‡ä»¶å—ï¼?):
                return
                
            # åˆ é™¤æ–‡ä»¶
            success = self.knowledge_manager.remove_file(file_id)
            if success:
                messagebox.showinfo("åˆ é™¤æˆåŠŸ", "æ–‡ä»¶å·²ä»çŸ¥è¯†åº“ä¸­åˆ é™¤")
                # åˆ·æ–°åˆ—è¡¨
                self.refresh_knowledge_list()
            else:
                messagebox.showerror("åˆ é™¤å¤±è´¥", "æ— æ³•åˆ é™¤æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦è¢«å ç”¨")
        except Exception as e:
            messagebox.showerror("åˆ é™¤é”™è¯¯", f"åˆ é™¤è¿‡ç¨‹ä¸­å‡ºé”? {str(e)}")

    def open_directory(self, path):
        """æ‰“å¼€ç›®å½•"""
        if os.path.exists(path):
            if sys.platform == 'win32':
                os.startfile(path)
            elif sys.platform == 'darwin':  # macOS
                os.system(f'open "{path}"')
            else:  # Linux
                os.system(f'xdg-open "{path}"')
        else:
            messagebox.showinfo("æç¤º", "ç›®å½•ä¸å­˜åœ?)
    
    def refresh_api_list(self):
        """åˆ·æ–°APIåˆ—è¡¨"""
        self.api_manager.load_other_apis()
        self.api_choices = self.api_manager.get_available_apis()
        self.api_dropdown['values'] = self.api_choices
        messagebox.showinfo("æˆåŠŸ", "APIåˆ—è¡¨å·²åˆ·æ–?)
    
    def save_settings(self):
        settings = {
            "openai": {
                "api_key": self.openai_key.get(),
                "model": self.openai_model.get()
            },
            "azure": {
                "api_key": self.azure_key.get(),
                "endpoint": self.azure_endpoint.get(),
                "deployment": self.azure_deployment.get()
            },
            "deepseek": {
                "api_key": self.deepseek_key.get(),
                "model": self.deepseek_model.get(),
                "base_url": self.deepseek_url.get()
            },
            "local": {
                "api": self.local_api.get()
            }
        }
        
        # æ›´æ–°APIç®¡ç†å™¨ä¸­çš„è®¾ç½?
        self.api_manager.settings.update(settings)
        self.api_manager.save_settings()
        
        messagebox.showinfo("æˆåŠŸ", "è®¾ç½®å·²ä¿å­?)
    
    def load_settings(self):
        try:
            if os.path.exists("config/settings.json"):
                with open("config/settings.json", "r") as f:
                    settings = json.load(f)
                
                if "openai" in settings:
                    self.openai_key.delete(0, tk.END)
                    self.openai_key.insert(0, settings["openai"].get("api_key", ""))
                    
                    self.openai_model.delete(0, tk.END)
                    self.openai_model.insert(0, settings["openai"].get("model", "gpt-4"))
                
                if "azure" in settings:
                    self.azure_key.delete(0, tk.END)
                    self.azure_key.insert(0, settings["azure"].get("api_key", ""))
                    
                    self.azure_endpoint.delete(0, tk.END)
                    self.azure_endpoint.insert(0, settings["azure"].get("endpoint", ""))
                    
                    self.azure_deployment.delete(0, tk.END)
                    self.azure_deployment.insert(0, settings["azure"].get("deployment", ""))

                if "deepseek" in settings:
                    self.deepseek_key.delete(0, tk.END)
                    self.deepseek_key.insert(0, settings["deepseek"].get("api_key", ""))
                    
                    self.deepseek_model.delete(0, tk.END)
                    self.deepseek_model.insert(0, settings["deepseek"].get("model", "deepseek-chat"))
                    
                    self.deepseek_url.delete(0, tk.END)
                    self.deepseek_url.insert(0, settings["deepseek"].get("base_url", "https://api.deepseek.com/v1"))
                
                if "local" in settings:
                    self.local_api.delete(0, tk.END)
                    self.local_api.insert(0, settings["local"].get("api", "http://localhost:8000/v1"))
        except Exception as e:
            print(f"åŠ è½½è®¾ç½®æ—¶å‡ºé”? {e}")

    def open_url(self, event):
        """æ‰“å¼€é“¾æ¥URL"""
        try:
            index = self.paper_details_text.index(f"@{event.x},{event.y}")
            # è·å–ç‚¹å‡»ä½ç½®çš„æ ‡ç­?
            tags = self.paper_details_text.tag_names(index)
            
            # æŸ¥æ‰¾é“¾æ¥URL
            for tag in tags:
                if tag.startswith("url="):
                    url = tag[4:]  # ç§»é™¤ "url=" å‰ç¼€
                    webbrowser.open(url)
                    self.paper_status_label.config(text=f"å·²åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€é“¾æ¥")
                    break
            
            # æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å¸¦æœ‰"link"æ ‡ç­¾çš„æ–‡æœ¬ï¼Œä½†æ²¡æœ‰url=å‰ç¼€
            if "link" in tags and not any(tag.startswith("url=") for tag in tags):
                # å°è¯•è·å–å½“å‰é€‰ä¸­çš„æ–‡æœ?
                try:
                    start = self.paper_details_text.index(f"{index} linestart")
                    end = self.paper_details_text.index(f"{index} lineend")
                    line_text = self.paper_details_text.get(start, end)
                    
                    # å°è¯•æå–URLæ ·å¼çš„æ–‡æœ?
                    url_match = re.search(r'https?://\S+', line_text)
                    if url_match:
                        url = url_match.group(0)
                        webbrowser.open(url)
                        self.paper_status_label.config(text=f"å·²åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€é“¾æ¥")
                except:
                    pass
        except Exception as e:
            self.paper_status_label.config(text=f"æ‰“å¼€é“¾æ¥å‡ºé”™: {str(e)}")

    def quick_access(self, event=None):
        """å¿«é€Ÿä¸‹è½½DOIæˆ–ArXiv ID"""
        input_text = self.doi_entry.get().strip()
        if not input_text:
            self.paper_status_label.config(text="è¯·è¾“å…¥DOIã€ArXiv IDæˆ–URL")
            return

        # æ£€æŸ¥æ˜¯å¦æ˜¯ArXiv ID
        arxiv_id = None
        # å¸¸è§çš„ArXiv IDæ ¼å¼: 2201.08239 æˆ?arxiv:2201.08239
        arxiv_pattern = r'(?:arxiv:)?(\d{4}\.\d{5}|\d{4}\.\d{4,5}v\d+)'
        arxiv_match = re.search(arxiv_pattern, input_text, re.IGNORECASE)
        
        if arxiv_match:
            arxiv_id = arxiv_match.group(1)
            # è°ƒç”¨ArXivä¸‹è½½å¤„ç†
            self.paper_status_label.config(text=f"æ£€æµ‹åˆ°ArXiv ID: {arxiv_id}ï¼Œæ­£åœ¨å‡†å¤‡ä¸‹è½?..")
            # åˆ›å»ºæµ‹è¯•è®ºæ–‡æ•°æ®
            test_paper = {
                'title': f'ArXiv Paper: {arxiv_id}',
                'authors': 'Unknown',
                'pdf_link': f'https://arxiv.org/pdf/{arxiv_id}.pdf',
                'url': f'https://arxiv.org/abs/{arxiv_id}',
                'abstract': 'Abstract not available',
                'source': 'ArXiv'
            }
            self.selected_paper = test_paper
            self.download_selected_paper()
            return
        
        # æå–DOI - é¦–å…ˆå°è¯•ç›´æ¥åŒ¹é…
        doi_match = re.search(r"\b(10\.\d{4,9}/[-._;()/:A-Z0-9]+)\b", input_text, re.IGNORECASE)
        
        # å¦‚æœæ²¡æœ‰ç›´æ¥åŒ¹é…åˆ°DOIï¼Œå°è¯•è§£æURLä¸­çš„DOI
        if not doi_match:
            # å°è¯•ä»URLè·¯å¾„ä¸­æå?
            url_match = re.search(r"https?://[^\s]+", input_text)
            if url_match:
                url = url_match.group(0)
                try:
                    from urllib.parse import urlparse, unquote
                    parsed_url = urlparse(url)
                    # æ£€æŸ¥è·¯å¾„ä¸­çš„DOI
                    path = unquote(parsed_url.path)
                    doi_in_path = re.search(r"\b(10\.\d{4,9}/[-._;()/:A-Z0-9]+)\b", path, re.IGNORECASE)
                    if doi_in_path:
                        doi_match = doi_in_path
                    else:
                        # æ£€æŸ¥æŸ¥è¯¢å‚æ•°ä¸­çš„DOI
                        query = unquote(parsed_url.query)
                        doi_in_query = re.search(r"\b(10\.\d{4,9}/[-._;()/:A-Z0-9]+)\b", query, re.IGNORECASE)
                        if doi_in_query:
                            doi_match = doi_in_query
                except:
                    pass
        
        # å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°DOI
        if not doi_match:
            self.paper_status_label.config(text="æ— æ³•è¯†åˆ«DOIæˆ–ArXiv IDï¼Œè¯·ç¡®è®¤è¾“å…¥æ ¼å¼æ­£ç¡®")
            return
            
        # æå–åŒ¹é…çš„DOI
        doi = doi_match.group(1)
        
        # æ¸…ç†DOIï¼ˆåˆ é™¤æœ«å°¾çš„æ ‡ç‚¹ç¬¦å·ï¼?
        doi = re.sub(r'[.,;]$', '', doi)
        
        # åˆ›å»ºæµ‹è¯•è®ºæ–‡æ•°æ®
        test_paper = {
            'title': f'DOI: {doi}',
            'authors': 'Unknown',
            'doi': doi,
            'url': f'https://doi.org/{doi}',
            'abstract': 'Abstract not available',
            'source': 'DOI'
        }
        self.selected_paper = test_paper
        self.paper_status_label.config(text=f"æ£€æµ‹åˆ°DOI: {doi}ï¼Œæ­£åœ¨å‡†å¤‡ä¸‹è½?..")
        # å°è¯•é€šè¿‡DOIä¸‹è½½
        self.download_selected_paper()

    def test_download_function(self):
        """æµ‹è¯•ä¸‹è½½åŠŸèƒ½æ˜¯å¦å·¥ä½œæ­£å¸¸"""
        # åˆ›å»ºä¸€ä¸ªç¡®å®šèƒ½æ­£å¸¸ä¸‹è½½çš„æµ‹è¯•æ•°æ?
        test_paper = {
            'title': 'Test Paper From ArXiv',
            'authors': 'Test Author',
            'pdf_link': 'https://arxiv.org/pdf/2201.08239.pdf',  # ä¸€ä¸ªç¡®å®šæœ‰æ•ˆçš„ArXivè®ºæ–‡
            'url': 'https://arxiv.org/abs/2201.08239',
            'abstract': 'Test abstract',
            'source': 'Test'
        }
        
        # è®¾ç½®ä¸ºå½“å‰é€‰ä¸­çš„è®ºæ–?
        self.selected_paper = test_paper
        
        # æ‰‹åŠ¨ç¡®è®¤ä¸‹è½½ç›®å½•å­˜åœ¨
        download_dir = "downloaded_papers"
        if not os.path.exists(download_dir):
            os.makedirs(download_dir)
            
        # æ›´æ–°UIçŠ¶æ€?
        self.paper_status_label.config(text="æ­£åœ¨æµ‹è¯•ä¸‹è½½åŠŸèƒ½ï¼Œä¸‹è½½ArXivä¸Šçš„æµ‹è¯•è®ºæ–‡...")
        
        # ç¡®è®¤PaperDownloaderä½¿ç”¨æ­£ç¡®çš„ç›®å½?
        self.paper_downloader.papers_dir = download_dir
        
        # ç¦ç”¨æŒ‰é’®é¿å…é‡å¤ç‚¹å‡»
        self.test_download_button.config(state="disabled", text="æ­£åœ¨æµ‹è¯•ä¸‹è½½...")
        
        # ä½¿ç”¨çº¿ç¨‹æ¥æ‰§è¡Œä¸‹è½?
        download_thread = threading.Thread(target=self._test_download_execute)
        download_thread.daemon = True
        download_thread.start()
        
        # åˆ‡æ¢åˆ°æ–‡çŒ®ä¸‹è½½æ ‡ç­¾é¡µ
        self.tabs.select(self.paper_tab)

    def _test_download_execute(self):
        """æ‰§è¡Œæµ‹è¯•ä¸‹è½½"""
        try:
            # é‡ç½®è¿›åº¦æ?
            self.root.after(0, lambda: self.download_progress.config(value=0))
            self.root.after(0, lambda: self.download_status.config(text="å‡†å¤‡ä¸‹è½½æµ‹è¯•æ–‡ä»¶..."))
            
            # ç›´æ¥ä½¿ç”¨requestsä¸‹è½½æ–‡ä»¶ï¼Œç»•è¿‡å¯èƒ½çš„é—®é¢˜
            # ä½¿ç”¨æ›´å¯é çš„arxivè®ºæ–‡ID
            arxiv_id = "2201.08239"
            url = f'https://arxiv.org/pdf/{arxiv_id}.pdf'
            
            # æ›´å…¨é¢çš„è¯·æ±‚å¤?
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7",
                "Accept-Encoding": "gzip, deflate, br",
                "Connection": "keep-alive",
                "Upgrade-Insecure-Requests": "1"
            }
            
            # è®¾ç½®æ–‡ä»¶åå’Œè·¯å¾„
            filename = "Test_Download_Success.pdf"
            filepath = os.path.join("downloaded_papers", filename)
            
            # å¦‚æœæ–‡ä»¶å·²å­˜åœ¨ï¼Œå…ˆåˆ é™?
            if os.path.exists(filepath):
                try:
                    os.remove(filepath)
                except:
                    pass
                
            # ç›´æ¥ä¸‹è½½
            self.root.after(0, lambda: self.download_progress.config(value=20))
            self.root.after(0, lambda: self.download_status.config(
                text="è¿æ¥åˆ?ArXiv æœåŠ¡å™?.."))
            
            # è®¾ç½®é‡è¯•æœºåˆ¶
            max_retries = 3
            retry_count = 0
            success = False
            error_message = ""
            
            while retry_count < max_retries and not success:
                try:
                    response = requests.get(
                        url, 
                        headers=headers, 
                        stream=True, 
                        timeout=45,  # å¢åŠ è¶…æ—¶æ—¶é—´
                        allow_redirects=True
                    )
                    
                    if response.status_code == 200:
                        # éªŒè¯å†…å®¹ç±»å‹
                        content_type = response.headers.get('Content-Type', '').lower()
                        if 'application/pdf' not in content_type and not url.lower().endswith('.pdf'):
                            self.root.after(0, lambda: self.download_status.config(
                                text=f"å†…å®¹ç±»å‹ä¸æ˜¯PDF: {content_type}"))
                            retry_count += 1
                            continue
                            
                        # è·å–æ–‡ä»¶å¤§å°
                        total_size = int(response.headers.get('content-length', 0))
                        
                        with open(filepath, 'wb') as f:
                            downloaded = 0
                            for i, chunk in enumerate(response.iter_content(chunk_size=8192)):
                                if chunk:
                                    f.write(chunk)
                                    downloaded += len(chunk)
                                    
                                    # æ›´æ–°è¿›åº¦æ¡ï¼Œä½†ä¸è¦å¤ªé¢‘ç¹
                                    if i % 10 == 0 and total_size > 0:
                                        progress = 20 + int((downloaded / total_size) * 80)
                                        self.root.after(0, lambda p=progress: self.download_progress.config(value=p))
                                        self.root.after(0, lambda d=downloaded, t=total_size: self.download_status.config(
                                            text=f"ä¸‹è½½ä¸? {d/1024/1024:.1f}MB / {t/1024/1024:.1f}MB"))
                        
                        # éªŒè¯æ–‡ä»¶
                        if os.path.exists(filepath) and os.path.getsize(filepath) > 10000:  # ç¡®ä¿æ–‡ä»¶è‡³å°‘æœ?0KB
                            # ä¸‹è½½æˆåŠŸï¼Œæ›´æ–°UI
                            success = True
                            self.root.after(0, lambda: self.download_progress.config(value=100))
                            self.root.after(0, lambda: self.download_status.config(
                                text=f"æµ‹è¯•ä¸‹è½½æˆåŠŸ!"))
                            self.root.after(0, lambda: self.paper_status_label.config(
                                text=f"æµ‹è¯•ä¸‹è½½æˆåŠŸï¼æ–‡ä»¶å·²ä¿å­˜ä¸ºï¼š{filename} ({os.path.getsize(filepath)/1024:.1f} KB)"))
                            self.root.after(0, lambda: self.test_download_button.config(
                                state="normal", text="æµ‹è¯•ä¸‹è½½åŠŸèƒ½"))
                        else:
                            # æ–‡ä»¶ä¸‹è½½ä½†å¯èƒ½æŸå?
                            if os.path.exists(filepath):
                                os.remove(filepath)
                            self.root.after(0, lambda: self.download_status.config(text="ä¸‹è½½çš„æ–‡ä»¶å¯èƒ½å·²æŸå"))
                            error_message = "ä¸‹è½½çš„æ–‡ä»¶å¯èƒ½å·²æŸåæˆ–ä¸å®Œæ•´"
                            retry_count += 1
                    else:
                        # ä¸‹è½½å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨é“¾æ?
                        if retry_count == 0:
                            # ç¬¬ä¸€æ¬¡å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨é“¾æ¥
                            url = f"https://arxiv.org/pdf/{arxiv_id}" # æ—?pdfåç¼€ï¼Œè®©æœåŠ¡å™¨å¤„ç?
                            retry_count += 1
                            self.root.after(0, lambda: self.download_status.config(
                                text=f"ç¬¬ä¸€æ¬¡å°è¯•å¤±è´?({response.status_code})ï¼Œä½¿ç”¨å¤‡ç”¨é“¾æ?.."))
                            continue
                        
                        # ä¸‹è½½å¤±è´¥
                        self.root.after(0, lambda: self.download_status.config(
                            text=f"ä¸‹è½½å¤±è´¥: {response.status_code}"))
                        error_message = f"HTTPçŠ¶æ€ç ï¼š{response.status_code}"
                        retry_count += 1
                
                except (requests.RequestException, IOError) as e:
                    # ç½‘ç»œé”™è¯¯æˆ–æ–‡ä»¶é”™è¯?
                    error_message = str(e)
                    self.root.after(0, lambda err=error_message: self.download_status.config(
                        text=f"ä¸‹è½½é”™è¯¯: {err}"))
                    retry_count += 1
                    time.sleep(2)  # ç­‰å¾…åé‡è¯?
            
            # å¤„ç†æœ€ç»ˆç»“æ?
            if not success:
                self.root.after(0, lambda: self.download_progress.config(value=0))
                self.root.after(0, lambda err=error_message: self.download_status.config(
                    text=f"ä¸‹è½½å¤±è´¥: {err}"))
                self.root.after(0, lambda err=error_message: self.paper_status_label.config(
                    text=f"æµ‹è¯•ä¸‹è½½å¤±è´¥ï¼š{err}"))
                self.root.after(0, lambda: self.test_download_button.config(
                    state="normal", text="æµ‹è¯•ä¸‹è½½åŠŸèƒ½"))
            
            # åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
            self.root.after(100, self.refresh_downloaded_files)
            
            # å¦‚æœæˆåŠŸï¼Œé«˜äº®æ˜¾ç¤ºä¸‹è½½çš„æ–‡ä»¶
            if success:
                self.root.after(500, lambda: self._highlight_file(filename))
                
        except Exception as e:
            # å‘ç”Ÿé”™è¯¯
            error_details = f"{type(e).__name__}: {str(e)}"
            self.root.after(0, lambda: self.download_progress.config(value=0))
            self.root.after(0, lambda: self.download_status.config(text="ä¸‹è½½å‡ºé”™"))
            self.root.after(0, lambda err=error_details: self.paper_status_label.config(
                text=f"æµ‹è¯•ä¸‹è½½å‡ºé”™: {err}"))
            self.root.after(0, lambda: self.test_download_button.config(
                state="normal", text="æµ‹è¯•ä¸‹è½½åŠŸèƒ½"))
    
    def _highlight_file(self, filename):
        """é«˜äº®æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨ä¸­çš„ç‰¹å®šæ–‡ä»¶"""
        try:
            # æŸ¥æ‰¾æ–‡ä»¶åœ¨åˆ—è¡¨ä¸­çš„ä½ç½?
            for i in range(self.downloaded_files_list.size()):
                if self.downloaded_files_list.get(i) == filename:
                    # æ¸…é™¤æ‰€æœ‰é€‰æ‹©
                    self.downloaded_files_list.selection_clear(0, tk.END)
                    # é€‰ä¸­ç›®æ ‡æ–‡ä»¶
                    self.downloaded_files_list.selection_set(i)
                    # æ»šåŠ¨ä½¿å…¶å¯è§
                    self.downloaded_files_list.see(i)
                    # é«˜äº®æ˜¾ç¤ºï¼ˆä¸æ˜¯æ‰€æœ‰å¹³å°æ”¯æŒï¼‰
                    try:
                        self.downloaded_files_list.itemconfig(i, {'bg': '#e0f0ff'})
                        # 3ç§’åæ¢å¤æ­£å¸¸èƒŒæ™¯
                        self.root.after(3000, lambda idx=i: 
                                       self.downloaded_files_list.itemconfig(idx, {'bg': ''}))
                    except:
                        pass  # å¦‚æœä¸æ”¯æŒèƒŒæ™¯è‰²æ›´æ”¹ï¼Œå¿½ç•¥é”™è¯?
                    break
        except Exception as e:
            print(f"é«˜äº®æ–‡ä»¶æ—¶å‡ºé”? {str(e)}")

    def open_url_in_browser(self, event=None):
        """åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€è®ºæ–‡é“¾æ¥"""
        if not self.selected_paper:
            self.paper_status_label.config(text="è¯·å…ˆé€‰æ‹©ä¸€ç¯‡è®ºæ–?)
            return
        
        url = self.selected_paper.get('browser_url', '') or self.selected_paper.get('url', '') or self.selected_paper.get('pdf_link', '')
        
        if not url:
            self.paper_status_label.config(text="æ²¡æœ‰å¯ç”¨çš„é“¾æ?)
            return
        
        # æ›´æ–°çŠ¶æ€?
        self.paper_status_label.config(text=f"æ­£åœ¨å°è¯•åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€é“¾æ¥...")
        
        # ä½¿ç”¨çº¿ç¨‹æ‰“å¼€æµè§ˆå™¨ï¼Œé¿å…é˜»å¡UI
        def open_browser_thread():
            try:
                # è®¾ç½®è¶…æ—¶æ—¶é—´
                timer = threading.Timer(15, lambda: self.root.after(0, lambda: self.paper_status_label.config(text="æ‰“å¼€é“¾æ¥è¶…æ—¶ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶é“¾æ¥: " + url)))
                timer.start()
                
                # å°è¯•æ‰“å¼€æµè§ˆå™?
                webbrowser.open(url)
                
                # å¦‚æœæˆåŠŸæ‰“å¼€ï¼Œå–æ¶ˆè¶…æ—¶è®¡æ—¶å™¨
                timer.cancel()
                self.root.after(0, lambda: self.paper_status_label.config(text=f"å·²åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€é“¾æ¥"))
                
            except Exception as e:
                error_msg = str(e)
                self.root.after(0, lambda: self.paper_status_label.config(text=f"æ‰“å¼€é“¾æ¥å‡ºé”™: {error_msg}"))
        
        # åˆ›å»ºå¹¶å¯åŠ¨çº¿ç¨?
        browser_thread = threading.Thread(target=open_browser_thread)
        browser_thread.daemon = True
        browser_thread.start()

    def copy_to_clipboard(self, text):
        """å¤åˆ¶æ–‡æœ¬åˆ°å‰ªè´´æ¿"""
        self.root.clipboard_clear()
        self.root.clipboard_append(text)
        self.paper_status_label.config(text="å·²å¤åˆ¶åˆ°å‰ªè´´æ?)

    def show_message(self, title, message):
        """æ˜¾ç¤ºæ¶ˆæ¯å¯¹è¯æ¡?""
        messagebox.showinfo(title, message)

    def show_paper_details(self, paper):
        """æ˜¾ç¤ºè®ºæ–‡è¯¦ç»†ä¿¡æ¯"""
        if not hasattr(self, 'paper_details_text'):
            return
            
        # æ¸…ç©ºå½“å‰å†…å®¹
        self.paper_details_text.delete(1.0, tk.END)
        
        # æ·»åŠ æ ‡é¢˜
        title = paper.get('title', 'æœªçŸ¥æ ‡é¢˜')
        self.paper_details_text.insert(tk.END, f"{title}\n\n", "title")
        
        # æ·»åŠ ä½œè€?
        authors = paper.get('authors', 'æœªçŸ¥ä½œè€?)
        self.paper_details_text.insert(tk.END, "ä½œè€? ", "heading")
        self.paper_details_text.insert(tk.END, f"{authors}\n\n")
        
        # æ·»åŠ å¹´ä»½
        year = paper.get('year', 'æœªçŸ¥å¹´ä»½')
        self.paper_details_text.insert(tk.END, "å¹´ä»½: ", "heading")
        self.paper_details_text.insert(tk.END, f"{year}\n\n")
        
        # æ·»åŠ æ¥æº
        source = paper.get('source', 'æœªçŸ¥æ¥æº')
        self.paper_details_text.insert(tk.END, "æ¥æº: ", "heading")
        self.paper_details_text.insert(tk.END, f"{source}\n\n")
        
        # æ·»åŠ æ‘˜è¦
        abstract = paper.get('abstract', '')
        if abstract:
            self.paper_details_text.insert(tk.END, "æ‘˜è¦: \n", "heading")
            self.paper_details_text.insert(tk.END, f"{abstract}\n\n")
        
        # æ·»åŠ é“¾æ¥
        url = paper.get('url', '')
        if url:
            self.paper_details_text.insert(tk.END, "é“¾æ¥: \n", "heading")
            # åˆ›å»ºå¸¦æœ‰URLæ ‡ç­¾çš„é“¾æ¥æ–‡æœ?
            tag_name = f"url={url}"
            self.paper_details_text.tag_configure(tag_name, foreground="blue", underline=1)
            self.paper_details_text.insert(tk.END, f"{url}\n\n", ("link", tag_name))
        
        # æ·»åŠ PDFé“¾æ¥ï¼ˆå¦‚æœæœ‰ï¼?
        pdf_link = paper.get('pdf_link', '')
        if pdf_link and pdf_link != url:
            self.paper_details_text.insert(tk.END, "PDFé“¾æ¥: \n", "heading")
            # åˆ›å»ºå¸¦æœ‰URLæ ‡ç­¾çš„PDFé“¾æ¥æ–‡æœ¬
            tag_name = f"url={pdf_link}"
            self.paper_details_text.tag_configure(tag_name, foreground="blue", underline=1)
            self.paper_details_text.insert(tk.END, f"{pdf_link}\n\n", ("link", tag_name))
        
        # æ·»åŠ DOI
        doi = paper.get('doi', '')
        if doi:
            self.paper_details_text.insert(tk.END, "DOI: ", "heading")
            doi_url = f"https://doi.org/{doi}"
            tag_name = f"url={doi_url}"
            self.paper_details_text.tag_configure(tag_name, foreground="blue", underline=1)
            self.paper_details_text.insert(tk.END, f"{doi}\n\n", ("link", tag_name))
        
        # æ·»åŠ ArXiv ID
        arxiv_id = paper.get('arxiv_id', '')
        if arxiv_id:
            self.paper_details_text.insert(tk.END, "ArXiv ID: ", "heading")
            arxiv_url = f"https://arxiv.org/abs/{arxiv_id}"
            tag_name = f"url={arxiv_url}"
            self.paper_details_text.tag_configure(tag_name, foreground="blue", underline=1)
            self.paper_details_text.insert(tk.END, f"{arxiv_id}\n\n", ("link", tag_name))
        
        # å…¶ä»–å…ƒæ•°æ?
        if 'citations' in paper:
            self.paper_details_text.insert(tk.END, "å¼•ç”¨æ•? ", "heading")
            self.paper_details_text.insert(tk.END, f"{paper['citations']}\n\n")
        
        if 'categories' in paper:
            self.paper_details_text.insert(tk.END, "åˆ†ç±»: ", "heading")
            self.paper_details_text.insert(tk.END, f"{paper['categories']}\n\n")

    def clear_paper_details(self):
        """æ¸…ç©ºè®ºæ–‡è¯¦æƒ…æ˜¾ç¤º"""
        if hasattr(self, 'paper_details_text'):
            self.paper_details_text.delete(1.0, tk.END)

    def cancel_search(self):
        """å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„æœç´?""
        if self.search_thread and self.search_thread.is_alive():
            self.cancel_search_flag = True
            self.search_status_var.set("æ­£åœ¨å–æ¶ˆ...")
            self.cancel_search_button.config(state="disabled")
        
    def add_paper_to_kb(self):
        """å°†å½“å‰é€‰ä¸­çš„è®ºæ–‡æ·»åŠ åˆ°çŸ¥è¯†åº?""
        if not self.selected_paper:
            self.paper_status_label.config(text="è¯·å…ˆé€‰æ‹©ä¸€ç¯‡è®ºæ–?)
            return
        
        # æ£€æŸ¥æ˜¯å¦å·²ä¸‹è½½
        if not hasattr(self, "last_download_path") or not self.last_download_path:
            # å¦‚æœæ²¡æœ‰ä¸‹è½½è®°å½•ï¼Œå°è¯•å…ˆä¸‹è½½
            self.paper_status_label.config(text="æ­£åœ¨å°è¯•ä¸‹è½½è®ºæ–‡...")
            self.download_selected_paper()
            
            # æ·»åŠ å»¶æ—¶ï¼Œç­‰å¾…ä¸‹è½½å®Œæˆ?
            def delayed_add():
                if hasattr(self, "last_download_path") and self.last_download_path and os.path.exists(self.last_download_path):
                    self.select_category_for_paper(self.last_download_path, self.selected_paper)
                else:
                    self.paper_status_label.config(text="è¯·å…ˆä¸‹è½½è®ºæ–‡ï¼Œç„¶åå†æ·»åŠ åˆ°çŸ¥è¯†åº“")
            
            self.root.after(3000, delayed_add)  # ç­‰å¾…3ç§?
            return
        
        if not os.path.exists(self.last_download_path):
            self.paper_status_label.config(text="ä¸‹è½½æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°ä¸‹è½?)
            return
        
        # æ‰“å¼€åˆ†åŒºé€‰æ‹©å¯¹è¯æ¡?
        self.select_category_for_paper(self.last_download_path, self.selected_paper)

    def add_downloaded_to_kb(self):
        """å°†å·²ä¸‹è½½çš„è®ºæ–‡æ·»åŠ åˆ°çŸ¥è¯†åº?""
        # è·å–é€‰ä¸­çš„æ–‡ä»?
        selection = self.downloaded_files_list.curselection()
        if not selection:
            self.paper_status_label.config(text="è¯·å…ˆé€‰æ‹©å·²ä¸‹è½½çš„è®ºæ–‡")
            return
        
        # è·å–æ–‡ä»¶è·¯å¾„
        index = selection[0]
        filename = self.downloaded_files_list.get(index)
        file_path = os.path.join(self.papers_dir, filename)
        
        if not os.path.exists(file_path):
            self.paper_status_label.config(text="æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·åˆ·æ–°åˆ—è¡?)
            return
        
        # å°è¯•æå–è®ºæ–‡å…ƒæ•°æ®ï¼ˆç®€å•å®ç°ï¼‰
        paper_data = self.extract_paper_metadata(filename)
        
        # æ‰“å¼€åˆ†åŒºé€‰æ‹©å¯¹è¯æ¡?
        self.select_category_for_paper(file_path, paper_data)

    def extract_paper_metadata(self, filename):
        """ä»æ–‡ä»¶åå°è¯•æå–è®ºæ–‡å…ƒæ•°æ?""
        paper_data = {
            'title': filename,
            'authors': 'æœªçŸ¥ä½œè€?,
            'year': '',
            'source': 'æœ¬åœ°æ–‡ä»¶'
        }
        
        # å°è¯•ä»æ–‡ä»¶åæå–æ›´å¤šä¿¡æ¯
        # ä¾‹å¦‚ï¼?Title_Author_2022.pdf æ ¼å¼
        parts = os.path.splitext(filename)[0].split('_')
        if len(parts) >= 3:
            year_match = re.search(r'(19|20)\d{2}', parts[-1])
            if year_match:
                paper_data['year'] = year_match.group(0)
                paper_data['authors'] = parts[-2]
                paper_data['title'] = '_'.join(parts[:-2])
        elif len(parts) == 2:
            # Title_Author.pdf
            paper_data['title'] = parts[0]
            paper_data['authors'] = parts[1]
        
        return paper_data

    def select_category_for_paper(self, file_path, paper_data):
        """æ˜¾ç¤ºåˆ†åŒºé€‰æ‹©å¯¹è¯æ¡?""
        try:
            # ç¡®ä¿çŸ¥è¯†åº“ç®¡ç†å™¨å·²åˆå§‹åŒ–
            if not hasattr(self, 'knowledge_manager'):
                self.knowledge_manager = KnowledgeManager()
                
            # åˆ›å»ºå¯¹è¯æ¡?
            dialog = tk.Toplevel(self.root)
            dialog.title("é€‰æ‹©çŸ¥è¯†åº“åˆ†åŒ?)
            dialog.geometry("450x350")
            dialog.transient(self.root)
            dialog.grab_set()
            
            # è®¾ç½®æœ€å°å°ºå¯?
            dialog.minsize(450, 350)
            
            # æ·»åŠ å¯¹è¯æ¡†å†…å®?
            main_frame = ttk.Frame(dialog, padding="10")
            main_frame.pack(fill="both", expand=True)
            
            # æ˜¾ç¤ºè®ºæ–‡ä¿¡æ¯
            info_frame = ttk.LabelFrame(main_frame, text="è®ºæ–‡ä¿¡æ¯")
            info_frame.pack(fill="x", padx=5, pady=5)
            
            title = paper_data.get('title', os.path.basename(file_path))
            authors = paper_data.get('authors', 'æœªçŸ¥ä½œè€?)
            
            title_label = ttk.Label(info_frame, text=f"æ ‡é¢˜: {title}", wraplength=400)
            title_label.pack(anchor="w", padx=5, pady=2)
            
            authors_label = ttk.Label(info_frame, text=f"ä½œè€? {authors}", wraplength=400)
            authors_label.pack(anchor="w", padx=5, pady=2)
            
            if 'year' in paper_data and paper_data['year']:
                year_label = ttk.Label(info_frame, text=f"å¹´ä»½: {paper_data['year']}")
                year_label.pack(anchor="w", padx=5, pady=2)
            
            # æ–‡ä»¶è·¯å¾„ä¿¡æ¯
            path_label = ttk.Label(info_frame, text=f"æ–‡ä»¶: {os.path.basename(file_path)}", wraplength=400)
            path_label.pack(anchor="w", padx=5, pady=2)
            
            # åˆ†åŒºé€‰æ‹©
            category_frame = ttk.LabelFrame(main_frame, text="é€‰æ‹©åˆ†åŒº")
            category_frame.pack(fill="both", expand=True, padx=5, pady=5)
            
            # åˆ›å»ºæ»šåŠ¨åŒºåŸŸä»¥é€‚åº”å¤§é‡åˆ†ç±»
            canvas = tk.Canvas(category_frame)
            scrollbar = ttk.Scrollbar(category_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # è·å–åˆ†ç±»åˆ—è¡¨ï¼Œå¦‚æœcategorieså±æ€§ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªé»˜è®¤åˆ—è¡?
            if not hasattr(self.knowledge_manager, 'categories') or not self.knowledge_manager.categories:
                self.knowledge_manager.categories = ["è®ºæ–‡", "å­¦ä¹ ç¬”è®°", "æ•™ç¨‹", "ä¹¦ç±", "å…¶ä»–"]
            
            # é»˜è®¤é€‰æ‹©"è®ºæ–‡"åˆ†ç±»
            category_var = tk.StringVar(value="è®ºæ–‡")
            
            # æ·»åŠ åˆ†ç±»é€‰é¡¹
            for category in self.knowledge_manager.categories:
                rb = ttk.Radiobutton(scrollable_frame, text=category, value=category, variable=category_var)
                rb.pack(anchor="w", padx=5, pady=3)
            
            # æ·»åŠ "æ–°å»ºåˆ†ç±»"é€‰é¡¹
            new_category_frame = ttk.Frame(main_frame)
            new_category_frame.pack(fill="x", padx=5, pady=5)
            
            ttk.Label(new_category_frame, text="æ–°å»ºåˆ†ç±»:").pack(side="left", padx=2)
            new_category_entry = ttk.Entry(new_category_frame, width=20)
            new_category_entry.pack(side="left", padx=2, fill="x", expand=True)
            
            def add_new_category():
                new_cat = new_category_entry.get().strip()
                if new_cat and new_cat not in self.knowledge_manager.categories:
                    self.knowledge_manager.categories.append(new_cat)
                    rb = ttk.Radiobutton(scrollable_frame, text=new_cat, value=new_cat, variable=category_var)
                    rb.pack(anchor="w", padx=5, pady=3)
                    category_var.set(new_cat)
                    new_category_entry.delete(0, tk.END)
            
            ttk.Button(new_category_frame, text="æ·»åŠ ", command=add_new_category).pack(side="left", padx=2)
            
            # æŒ‰é’®åŒºåŸŸ
            button_frame = ttk.Frame(main_frame)
            button_frame.pack(fill="x", padx=5, pady=10)
            
            # ç¡®å®šæŒ‰é’®
            def confirm():
                try:
                    selected_category = category_var.get()
                    
                    # æ£€æŸ¥çŸ¥è¯†åº“è·¯å¾„
                    kb_path = self.knowledge_manager.knowledge_base_dir
                    if not os.path.exists(kb_path):
                        os.makedirs(kb_path, exist_ok=True)
                    
                    # æ˜¾ç¤ºè¿›åº¦ä¿¡æ¯
                    self.paper_status_label.config(text=f"æ­£åœ¨æ·»åŠ åˆ°çŸ¥è¯†åº“: {selected_category}...")
                    
                    # æ·»åŠ åˆ°çŸ¥è¯†åº“
                    success, new_filename = self.knowledge_manager.add_paper_to_knowledge_base(
                        file_path, paper_data, selected_category)
                    
                    if success:
                        self.paper_status_label.config(text=f"å·²æˆåŠŸæ·»åŠ åˆ°çŸ¥è¯†åº? {selected_category}")
                        
                        # åˆ·æ–°çŸ¥è¯†åº“åˆ—è¡¨ï¼ˆå¦‚æœåœ¨çŸ¥è¯†åº“é€‰é¡¹å¡ä¸­ï¼?
                        if hasattr(self, 'knowledge_list') and self.knowledge_list:
                            self.refresh_knowledge_list()
                            
                        dialog.destroy()
                        self.show_message("æ·»åŠ æˆåŠŸ", f"è®ºæ–‡å·²æˆåŠŸæ·»åŠ åˆ°çŸ¥è¯†åº“\nåˆ†ç±»: {selected_category}\næ–‡ä»¶: {new_filename}")
                    else:
                        self.paper_status_label.config(text="æ·»åŠ åˆ°çŸ¥è¯†åº“å¤±è´¥")
                        messagebox.showerror("æ·»åŠ å¤±è´¥", "æ— æ³•æ·»åŠ æ–‡ä»¶åˆ°çŸ¥è¯†åº“ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶å’Œæƒé™ã€?)
                except Exception as e:
                    self.paper_status_label.config(text=f"æ·»åŠ åˆ°çŸ¥è¯†åº“æ—¶å‡ºé”? {str(e)}")
                    messagebox.showerror("é”™è¯¯", f"æ·»åŠ åˆ°çŸ¥è¯†åº“æ—¶å‡ºé”?\n{str(e)}")
                    dialog.destroy()
            
            ttk.Button(button_frame, text="ç¡®å®š", command=confirm).pack(side="right", padx=5, pady=5)
            ttk.Button(button_frame, text="å–æ¶ˆ", command=dialog.destroy).pack(side="right", padx=5, pady=5)
            
            # æ˜¾ç¤ºå¯¹è¯æ¡?
            dialog.wait_window()
        except Exception as e:
            self.paper_status_label.config(text=f"æ‰“å¼€åˆ†åŒºé€‰æ‹©å¯¹è¯æ¡†æ—¶å‡ºé”™: {str(e)}")
            messagebox.showerror("é”™è¯¯", f"æ— æ³•æ‰“å¼€åˆ†åŒºé€‰æ‹©å¯¹è¯æ¡?\n{str(e)}")

    def _handle_download_exception(self, e, url, filepath=None):
        """å¤„ç†ä¸‹è½½è¿‡ç¨‹ä¸­å¯èƒ½å‡ºç°çš„å„ç§å¼‚å¸¸æƒ…å†µï¼Œæä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯å’Œå»ºè®®
        
        Args:
            e: å¼‚å¸¸å¯¹è±¡
            url: æ­£åœ¨ä¸‹è½½çš„URL
            filepath: å¯èƒ½å·²éƒ¨åˆ†ä¸‹è½½çš„æ–‡ä»¶è·¯å¾„
            
        Returns:
            tuple: (é”™è¯¯æ¶ˆæ¯, é”™è¯¯æ ‡é¢˜, æ˜¯å¦å¯èƒ½ä¸ºæƒé™é—®é¢?
        """
        error_type = type(e).__name__
        error_message = str(e)
        error_title = "ä¸‹è½½é”™è¯¯"
        permission_issue = False
        
        # æ¸…ç†å¯èƒ½å·²éƒ¨åˆ†ä¸‹è½½çš„æ–‡ä»¶
        if filepath and os.path.exists(filepath):
            try:
                os.remove(filepath)
            except:
                pass
                
        # æ ¹æ®å¼‚å¸¸ç±»å‹å¤„ç†ä¸åŒçš„é”™è¯¯æƒ…å†?
        if isinstance(e, requests.exceptions.SSLError):
            error_message = f"SSLè¯ä¹¦éªŒè¯å¤±è´¥ã€‚å¯èƒ½åŸå› ï¼š\n1. ç½‘ç»œè¿æ¥ä¸å®‰å…¨\n2. ç³»ç»Ÿæ—¥æœŸæ—¶é—´è®¾ç½®é”™è¯¯\n3. SSLè¯ä¹¦å·²è¿‡æœ?
            error_title = "SSLè¯ä¹¦é”™è¯¯"
            
        elif isinstance(e, requests.exceptions.ConnectionError):
            error_message = f"è¿æ¥é”™è¯¯ã€‚å¯èƒ½åŸå› ï¼š\n1. ç½‘ç»œè¿æ¥ä¸ç¨³å®š\n2. ç›®æ ‡æœåŠ¡å™¨æ— æ³•è®¿é—®\n3. é˜²ç«å¢™é˜»æ­¢äº†è¿æ¥"
            error_title = "è¿æ¥é”™è¯¯"
            
        elif isinstance(e, requests.exceptions.Timeout):
            error_message = f"è¯·æ±‚è¶…æ—¶ã€‚å¯èƒ½åŸå› ï¼š\n1. ç½‘ç»œé€Ÿåº¦è¾ƒæ…¢\n2. æœåŠ¡å™¨å“åº”æ—¶é—´è¿‡é•¿\n3. æ–‡ä»¶å¤ªå¤§ï¼Œä¸‹è½½è¶…æ—?
            error_title = "è¯·æ±‚è¶…æ—¶"
            
        elif isinstance(e, requests.exceptions.TooManyRedirects):
            error_message = f"é‡å®šå‘è¿‡å¤šã€‚å¯èƒ½åŸå› ï¼š\n1. URLé‡å®šå‘å¾ªç¯\n2. æœåŠ¡å™¨é…ç½®é”™è¯?
            error_title = "é‡å®šå‘é”™è¯?
            
        elif isinstance(e, requests.exceptions.HTTPError):
            status_code = e.response.status_code if hasattr(e, 'response') and hasattr(e.response, 'status_code') else "æœªçŸ¥"
            
            if status_code == 403:
                error_message = f"è®¿é—®è¢«æ‹’ç»?(403 Forbidden)ã€‚å¯èƒ½åŸå› ï¼š\n1. éœ€è¦ç™»å½•å‡­è¯\n2. IPè¢«ç¦æ­¢\n3. åœ°ç†ä½ç½®é™åˆ¶"
                error_title = "è®¿é—®è¢«æ‹’ç»?
                permission_issue = True
                
            elif status_code == 404:
                error_message = f"èµ„æºæœªæ‰¾åˆ?(404 Not Found)ã€‚å¯èƒ½åŸå› ï¼š\n1. URLé”™è¯¯\n2. æ–‡ä»¶å·²è¢«ç§»é™¤\n3. èµ„æºä¸å­˜åœ?
                error_title = "èµ„æºæœªæ‰¾åˆ?
                
            elif status_code == 429:
                error_message = f"è¯·æ±‚è¿‡å¤š (429 Too Many Requests)ã€‚å¯èƒ½åŸå› ï¼š\n1. çŸ­æ—¶é—´å†…å‘é€äº†å¤ªå¤šè¯·æ±‚\n2. IPè¢«é™æµ\n3. éœ€è¦ç­‰å¾…ä¸€æ®µæ—¶é—´å†è¯?
                error_title = "è¯·æ±‚é¢‘ç‡é™åˆ¶"
                
            elif 500 <= status_code < 600:
                error_message = f"æœåŠ¡å™¨é”™è¯?({status_code})ã€‚å¯èƒ½åŸå› ï¼š\n1. æœåŠ¡å™¨å†…éƒ¨é”™è¯¯\n2. æœåŠ¡å™¨è¿‡è½½\n3. æœåŠ¡å™¨ç»´æŠ¤ä¸­"
                error_title = "æœåŠ¡å™¨é”™è¯?
                
            else:
                error_message = f"HTTPé”™è¯¯: {status_code}ã€‚URL: {url}"
                error_title = "HTTPé”™è¯¯"
        
        elif isinstance(e, IOError) and ("Permission" in str(e) or "æ‹’ç»è®¿é—®" in str(e)):
            error_message = f"æ–‡ä»¶ç³»ç»Ÿæƒé™é”™è¯¯ã€‚å¯èƒ½åŸå› ï¼š\n1. æ²¡æœ‰å†™å…¥æƒé™\n2. æ–‡ä»¶è¢«å…¶ä»–ç¨‹åºå ç”¨\n3. ç³»ç»Ÿé™åˆ¶"
            error_title = "æƒé™é”™è¯¯"
            permission_issue = True
            
        elif "Memory" in error_type or "å†…å­˜" in error_message:
            error_message = f"å†…å­˜ä¸è¶³ã€‚å¯èƒ½åŸå› ï¼š\n1. æ–‡ä»¶å¤ªå¤§\n2. ç³»ç»Ÿèµ„æºä¸è¶³\n3. å…¶ä»–ç¨‹åºå ç”¨å†…å­˜"
            error_title = "å†…å­˜é”™è¯¯"
            
        # æä¾›å»ºè®®è§£å†³æ–¹æ¡ˆ
        suggestions = [
            "1. æ£€æŸ¥ç½‘ç»œè¿æ¥æ˜¯å¦ç¨³å®?,
            "2. å°è¯•ä½¿ç”¨VPNæˆ–ä»£ç†æœåŠ?,
            "3. ç›´æ¥é€šè¿‡æµè§ˆå™¨æ‰‹åŠ¨ä¸‹è½?,
            "4. å°è¯•å…¶ä»–æ–‡çŒ®æ¥æº",
            "5. æ£€æŸ¥ç³»ç»Ÿæ—¶é—´è®¾ç½®æ˜¯å¦æ­£ç¡?
        ]
        
        if permission_issue:
            suggestions.extend([
                "6. ç¡®ä¿åº”ç”¨æœ‰è¶³å¤Ÿçš„æ–‡ä»¶è®¿é—®æƒé™",
                "7. ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œç¨‹åº",
                "8. å…³é—­å¯èƒ½å ç”¨æ–‡ä»¶çš„ç¨‹åº?
            ])
            
        full_message = f"{error_message}\n\nå»ºè®®è§£å†³æ–¹æ¡ˆ:\n" + "\n".join(suggestions)
        
        # è®°å½•å¼‚å¸¸
        logging.error(f"ä¸‹è½½å¼‚å¸¸: {error_title} - {error_type}: {error_message}")
        logging.error(f"URL: {url}")
        
        return full_message, error_title, permission_issue

def set_console_encoding():
    """è®¾ç½®æ§åˆ¶å°ç¼–ç ï¼Œç¡®ä¿æ­£ç¡®æ˜¾ç¤ºä¸­æ–‡"""
    try:
        if sys.platform == 'win32':
            # Windowså¹³å°ä¸‹è®¾ç½®æ§åˆ¶å°ç¼–ç 
            import ctypes
            # è®¾ç½®æ§åˆ¶å°ä»£ç é¡µä¸ºUTF-8
            ctypes.windll.kernel32.SetConsoleCP(65001)  # è®¾ç½®æ§åˆ¶å°è¾“å…¥ä»£ç é¡µä¸ºUTF-8
            ctypes.windll.kernel32.SetConsoleOutputCP(65001)  # è®¾ç½®æ§åˆ¶å°è¾“å‡ºä»£ç é¡µä¸ºUTF-8
            
            # ç¡®ä¿sys.stdoutä½¿ç”¨UTF-8ç¼–ç 
            if hasattr(sys.stdout, 'reconfigure'):
                sys.stdout.reconfigure(encoding='utf-8')
            
            print("æ§åˆ¶å°ç¼–ç å·²è®¾ç½®ä¸ºUTF-8")
    except Exception as e:
        print(f"è®¾ç½®æ§åˆ¶å°ç¼–ç æ—¶å‡ºé”™: {str(e)}")

def main():
    """ä¸»ç¨‹åºå…¥å£ç‚¹"""
    # æ£€æŸ¥å‘½ä»¤è¡Œå‚æ•°
    import sys
    test_mode = False
    if len(sys.argv) > 1:
        if sys.argv[1] == "--test-download":
            test_mode = True

    # åˆ›å»ºä¸»çª—å?
    root = tk.Tk()
    root.title("AIå¯¹è¯åŠ©æ‰‹ - è®ºæ–‡ä¸‹è½½å·¥å…·")
    
    # è°ƒæ•´åˆå§‹çª—å£å¤§å°
    root.geometry("1000x800")
    
    # åˆå§‹åŒ–åº”ç”?
    app = AIAssistant(root)
    
    # å¦‚æœæŒ‡å®šäº†æµ‹è¯•ä¸‹è½½ï¼Œåˆ™åœ¨åŠ è½½åè‡ªåŠ¨æ‰§è¡Œæµ‹è¯?
    if test_mode:
        root.after(1000, app.test_download_function)
        # åˆ‡æ¢åˆ°æ–‡çŒ®ä¸‹è½½æ ‡ç­¾é¡µ
        app.tabs.select(app.paper_tab)
    
    # å¯åŠ¨ä¸»å¾ªç?
    root.mainloop()

if __name__ == "__main__":
    # è®¾ç½®æ§åˆ¶å°ç¼–ç ?
    set_console_encoding()
    
    # æ£€æŸ¥å¹¶ä¿®å¤å¯èƒ½çš„ç¼–ç é—®é¢?
    check_encoding_issues()
    
    # ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨
    if not os.path.exists("downloaded_papers"):
        os.makedirs("downloaded_papers", exist_ok=True)
    
    # åˆ›å»ºæµ‹è¯•ä¸‹è½½æ‰¹å¤„ç†æ–‡ä»?
    create_test_batch_file()
    
    # è¿è¡Œä¸»ç¨‹åº?
    main() 
